# 1.体系结构

本章涵盖了分布式系统的主要体系结构特征。如果你对自己想要构建的东西没有一点概念，你就无法构建一个系统。如果你不知道它的工作环境，你就无法建造它。GUI 程序不同于批处理程序；游戏程序不同于商业程序；分布式程序不同于独立程序。他们都有自己的方法、共同的模式、通常会出现的问题以及常用的解决方案。

本章涵盖了分布式系统的高级架构方面。有许多方法来看待这样的系统，其中许多是处理。

## 协议层

分布式系统很难。这涉及到多台计算机，它们必须以某种方式连接起来。必须编写程序在系统中的每台计算机上运行，并且它们都必须合作来完成分布式任务。

处理复杂性的通常方法是把它分解成更小更简单的部分。这些部分有自己的结构，但它们也有与其他相关部分通信的定义方式。在分布式系统中，这些部分被称为协议层，它们有明确定义的功能。它们形成一个堆栈，每一层都与上一层和下一层通信。各层之间的通信由协议定义。

网络通信要求协议涵盖高层应用通信，一直到有线通信，以及协议层封装所处理的复杂性。

### ISO 开放系统互连协议

尽管 OSI(开放系统互连)协议从未被正确实现，但它已经成为谈论和影响分布式系统设计的一个重要因素。通常如图 [1-1](#Fig1) 所示。

![A436770_1_En_1_Fig1_HTML.gif](A436770_1_En_1_Fig1_HTML.gif)

图 1-1。

The Open Systems Interconnect protocol

### OSI 层

每层的功能自下而上如下:

*   物理层使用电、光或无线电技术传送比特流。
*   数据链路层将信息包放入网络帧中，以便通过物理层传输，然后再放回信息包中。
*   网络层提供交换和路由技术。
*   传输层在终端系统之间提供透明的数据传输，并负责端到端的错误恢复和流量控制。
*   会话层建立、管理和终止应用程序之间的连接。
*   表示层提供了与数据表示(如加密)差异的独立性。
*   应用层支持应用程序和最终用户流程。

### TCP/IP 协议

当 OSI 模型被争论、辩论、部分实现和争论的时候，DARPA 互联网研究项目正忙于建立 TCP/IP 协议。这些都取得了巨大的成功，并导致了互联网(与资本)。这是一个简单得多的堆栈，如图 [1-2](#Fig2) 所示。

![A436770_1_En_1_Fig2_HTML.gif](A436770_1_En_1_Fig2_HTML.gif)

图 1-2。

The TCP/IP protocols

### 一些替代协议

尽管看起来很像，但 TCP/IP 协议并不是现存的唯一协议，从长远来看，它甚至可能不是最成功的。维基百科的网络协议列表(见 [`https://en.wikipedia.org/wiki/List_of_network_protocols_(OSI_model)`](https://en.wikipedia.org/wiki/List_of_network_protocols_(OSI_model)) )在每一个 ISO 层都有一个巨大的数字。其中许多协议已经过时或用处不大，但由于各种领域的技术进步，如太空互联网和物联网，总会有新协议的空间。

本书的重点是 TCP/IP(包括 UDP)层，但是您应该知道还有其他层。

## 建立关系网

网络是连接称为主机的终端系统的通信系统。连接机制可能是铜线、以太网、光纤或无线，但这不是我们在这里关心的。局域网(LAN)将相距很近的计算机连接起来，这些计算机通常属于一个家庭、小型组织或大型组织的一部分。

广域网(WAN)将计算机连接到更大的物理区域，如城市之间。还有其他类型，如城域网，个人局域网，甚至体域网。

互联网是两个或多个不同网络的连接，通常是局域网或广域网。内部网是所有网络都属于一个组织的互联网。

互联网和内部网有很大的不同。典型地，内部网将处于单一的管理控制之下，这将强加单一的一组一致的策略。另一方面，互联网不会由一个机构控制，对不同部分的控制甚至可能不兼容。

这种差异的一个小例子是，内部网通常被运行特定操作系统的标准化版本的少数供应商限制在计算机上。另一方面，互联网通常会有不同的计算机和操作系统的大杂烩。

这本书的技术适用于互联网。它们对内部网也是有效的，但在那里你也会发现专门的、不可移植的系统。

此外，还有所有互联网的“母亲”:互联网。这只是一个非常非常大的互联网，连接我们和谷歌，我的电脑和你的电脑，等等。

## 方法

网关是用于连接两个或多个网络的实体的通称。中继器在物理层工作，将信息从一个子网复制到另一个子网。网桥工作在数据链路层，在网络之间复制帧。路由器在网络层运行，不仅在网络间传输信息，还决定路由。

## 分组封装

OSI 或 TCP/IP 堆栈中各层之间的通信是通过将数据包从一层发送到下一层，然后最终通过网络完成的。每一层都有它必须保存的关于自己层的管理信息。当数据包向下传递时，它会将报头信息添加到从上一层接收的数据包中。在接收端，当数据包向上移动时，这些报头会被删除。

例如，TFTP(普通文件传输协议)将文件从一台计算机移动到另一台计算机。它使用 IP 协议之上的 UDP 协议，可以通过以太网发送。如图 [1-3](#Fig3) 所示。

![A436770_1_En_1_Fig3_HTML.gif](A436770_1_En_1_Fig3_HTML.gif)

图 1-3。

The TFTP (Trivial File Transfer Protocol)

通过以太网传输的数据包当然是最底层的。

## 连接模型

为了让两台计算机进行通信，它们必须建立一条路径，通过这条路径，它们可以在一个会话中至少发送一条消息。对此有两种主要模式:

*   面向连接
*   无连接传输模式

### 面向连接

为会话建立单个连接。双向通信沿着连接流动。当会话结束时，连接断开。这类似于电话交谈。TCP 就是一个例子。

### 无连接传输模式

在无连接系统中，消息是相互独立发送的。打个比方，普通邮件。无连接消息可能会无序到达。IP 协议就是一个例子。UDP 是 IP 之上的无连接协议，因为它的重量轻得多，所以经常被用作 TCP 的替代协议。

面向连接的传输可以建立在无连接传输之上——TCP over IP。无连接传输可以建立在面向连接的传输之上——HTTP over TCP。

这些可以有变化。例如，会话可能强制消息到达，但可能无法保证它们按照发送的顺序到达。然而，这两个是最常见的。

## 通信模型

在分布式系统中，会有许多组件运行，它们必须相互通信。有两种主要的模型，消息传递和远程过程调用。

### 信息传递

一些非过程化语言建立在消息传递的原则上。并发语言经常使用这种机制，最著名的例子可能是 UNIX 管道。UNIX 管道是字节的管道，但这不是固有的限制:微软的 PowerShell 可以沿其管道发送对象，Parlog 等并发语言可以在并发进程之间的消息中发送任意逻辑数据结构。

消息传递是分布式系统的基本机制。建立一个连接，然后输入一些数据。在另一端，找出消息是什么，并对其作出响应，可能发送回消息。这如图 [1-4](#Fig4) 所示。

![A436770_1_En_1_Fig4_HTML.gif](A436770_1_En_1_Fig4_HTML.gif)

图 1-4。

The message passing communications model

事件驱动系统以类似的方式工作。在底层，`node.js`运行一个事件循环，等待 I/O 事件，为这些事件分派处理程序并做出响应。在更高层次上，大多数用户界面系统使用事件循环等待用户输入，而在网络世界中，Ajax 使用`XMLHttpRequest`来发送和接收请求。

### 远程过程得

在任何系统中，都有信息和流控制从系统的一部分到另一部分的转移。在过程语言中，这可能由过程调用组成，其中信息被放在调用堆栈上，然后控制流被转移到程序的另一部分。

即使是过程调用，也会有变化。代码可以是静态链接的，以便控制从程序的可执行代码的一部分转移到另一部分。由于库例程的使用越来越多，在动态链接库(dll)中拥有这样的代码已经变得很常见，在动态链接库中，控制转移到一段独立的代码。

dll 与调用代码运行在同一台计算机上。将控制权转移给运行在不同机器上的过程是一个简单的(概念性的)步骤。这其中的机制并不简单！然而，这种控制模式导致了远程过程调用(RPC ),这将在后面的章节中详细讨论。如图 [1-5](#Fig5) 所示。

![A436770_1_En_1_Fig5_HTML.gif](A436770_1_En_1_Fig5_HTML.gif)

图 1-5。

The remote procedure call communications model

有很多这样的例子:一些基于特定的编程语言，比如 Go rpc 包(在第 [13](13.html) 章中讨论)或者覆盖多种语言的 rpc 系统，比如 SOAP 和 Google 的 grpc。

## 分布式计算模型

在最高层次上，我们可以考虑分布式系统组件的等价或不等价。最常见的情况是非对称的:客户端向服务器发送请求，服务器做出响应。这是一个客户机-服务器系统。

如果两个组件是等价的，都能够发起和响应消息，那么我们就有了一个对等系统。注意，这是一个逻辑分类:一个对等体可能是 16000 核的超级计算机，另一个可能是手机。但是，如果两者的行为相似，那么他们就是同龄人。

如图 [1-6](#Fig6) 所示。

![A436770_1_En_1_Fig6_HTML.gif](A436770_1_En_1_Fig6_HTML.gif)

图 1-6。

Client-sever versus peer-to-peer systems

## 客户-服务器系统

客户端-服务器系统的另一个视图如图 [1-7](#Fig7) 所示。

![A436770_1_En_1_Fig7_HTML.gif](A436770_1_En_1_Fig7_HTML.gif)

图 1-7。

The client-server system

需要了解系统组件的开发人员可能持有这种观点。这也是用户可能持有的观点:浏览器的用户知道它正在她的系统上运行，但是正在与别处的服务器通信。

## 客户端-服务器应用程序

有些应用程序可能是无缝分布的，用户并不知道它是分布式的。用户将看到他们的系统视图，如图 [1-8](#Fig8) 所示。

![A436770_1_En_1_Fig8_HTML.gif](A436770_1_En_1_Fig8_HTML.gif)

图 1-8。

The user’s view of the system

## 服务器分布

客户机-服务器系统不必简单。基本模型是单客户端、单服务器系统，如图 [1-9](#Fig9) 所示。

![A436770_1_En_1_Fig9_HTML.gif](A436770_1_En_1_Fig9_HTML.gif)

图 1-9。

The single client, single server system

然而，你也可以有多个客户端，单个服务器，如图 [1-10](#Fig10) 所示。

![A436770_1_En_1_Fig10_HTML.gif](A436770_1_En_1_Fig10_HTML.gif)

图 1-10。

The multiple clients, single server system

在这个系统中，主服务器接收请求，并不是一次处理一个请求，而是将它们传递给其他服务器来处理。当可能有并发客户端时，这是一个常见的模型。

还有单客户端，多服务器，如图 [1-11](#Fig11) 所示。

![A436770_1_En_1_Fig11_HTML.gif](A436770_1_En_1_Fig11_HTML.gif)

图 1-11。

The single client, multiple servers system

当一个服务器需要充当其他服务器的客户端时，例如业务逻辑服务器从数据库服务器获取信息，这种类型的系统经常出现。当然，也可能有多个客户端和多个服务器。

## 沟通流程

前面的图表显示了系统高层组件之间的连接视图。数据将在这些组件之间流动，并且可以通过多种方式流动，这将在下面的部分中讨论。

### 同步通信

在同步通信中，一方将发送消息并阻塞，等待回复。这通常是实现起来最简单的模型，仅仅依赖于阻塞 I/O。但是，可能需要一个超时机制，以防某些错误意味着永远不会发送回复。

### 异步通信

在异步通信中，一方发送消息，而不是等待回复，继续进行其他工作。当回复最终到来时，它被处理。这可能是在另一个线程中或通过中断当前线程。这种应用程序更难构建，但使用起来更加灵活。

### 流式通信

在流式通信中，一方发送连续的消息流。在线视频就是一个很好的例子。该流可能需要实时处理，可能容忍或不容忍丢失，并且可以是单向的或允许反向通信，如在控制消息中。

### 发布/订阅

在发布/订阅系统中，各方订阅主题，其他人发布主题。正如 Twitter 所展示的那样，这可以是小规模的，也可以是大规模的。

## 成分分布

分解许多应用程序的一个简单而有效的方法是将它们看作由三部分组成:

*   演示组件
*   应用逻辑
*   数据存取

表示组件负责与用户的交互，包括显示数据和收集输入。它可以是具有按钮、列表、菜单等的现代 GUI 界面。，还是比较老的命令行风格的界面，提问得到答案。它还可以包含更广泛的交互风格，例如与诸如收银机、ATM 等物理设备的交互。它还可以涵盖与非人类用户的交互，如在机器对机器系统中。细节在这个层面并不重要。

应用程序逻辑负责解释用户的响应、应用业务规则、准备查询以及管理来自第三方组件的响应。

数据访问组件负责存储和检索数据。这通常会通过数据库，但不是必须的。

### Gartner 分类

基于应用程序的这种三重分解，Gartner 考虑了如何在客户机-服务器系统中分配组件。他们提出了五种模型，如图 [1-12](#Fig12) 所示。

![A436770_1_En_1_Fig12_HTML.gif](A436770_1_En_1_Fig12_HTML.gif)

图 1-12。

Gartner’s five models

#### 示例:分布式数据库

*   Gartner classification : 1 (see Figure [1-13](#Fig13))

    ![A436770_1_En_1_Fig13_HTML.gif](A436770_1_En_1_Fig13_HTML.gif)

    图 1-13。

    Gartner example 1

现代手机就是很好的例子。由于内存有限，他们可能会在本地存储一小部分数据库，这样他们通常可以快速响应。然而，如果需要的数据不是本地保存的，则可以向远程数据库请求该附加数据。

谷歌地图是另一个很好的例子。所有的地图都在谷歌的服务器上。当用户请求时,“附近”的地图也被下载到浏览器的一个小数据库中。当用户稍微移动地图时，所需的额外位已经在本地存储中，以便快速响应。

#### 示例:网络文件服务

Gartner classification 2 允许远程客户端访问共享文件系统，如图 [1-14](#Fig14) 所示。

![A436770_1_En_1_Fig14_HTML.gif](A436770_1_En_1_Fig14_HTML.gif)

图 1-14。

Gartner example 2

这样的系统有很多例子:NFS、微软股份、DCE 等等。

#### 示例:Web

Gartner 分类 3 的一个例子是带有 Java 小程序或 JavaScript、CGI 脚本或类似程序(Ruby on Rails 等)的 Web。)在服务器端。这是一个分布式超文本系统，有许多附加机制，如图 [1-15](#Fig15) 所示。

![A436770_1_En_1_Fig15_HTML.gif](A436770_1_En_1_Fig15_HTML.gif)

图 1-15。

Gartner example 3

#### 示例:终端仿真

Gartner 分类 4 的一个例子是终端仿真。这允许远程系统作为本地系统的普通终端，如图 [1-16](#Fig16) 所示。

![A436770_1_En_1_Fig16_HTML.gif](A436770_1_En_1_Fig16_HTML.gif)

图 1-16。

Gartner example 4

Telnet 是这方面最常见的例子。

#### 示例:安全外壳

UNIX 上的安全 shell 允许您连接到远程系统，在那里运行命令，并在本地显示演示。演示文稿在远程机器上准备，并在本地显示。在 Windows 下，远程桌面的行为类似。参见图 [1-17](#Fig17) 。

![A436770_1_En_1_Fig17_HTML.gif](A436770_1_En_1_Fig17_HTML.gif)

图 1-17。

Gartner example 4

### 三层模型

当然，如果您有两层，那么您可以有三层、四层或更多层。一些三层可能性如图 [1-18](#Fig18) 所示。

![A436770_1_En_1_Fig18_HTML.gif](A436770_1_En_1_Fig18_HTML.gif)

图 1-18。

Three-tier models

现代网络是最右边的一个很好的例子。后端由数据库组成，通常运行存储过程来保存一些数据库逻辑。中间层是 HTTP 服务器，如运行 PHP 脚本(或 Ruby on Rails，或 JSP 页面等)的 Apache。).这将管理一些逻辑，并将 HTML 页面等数据存储在本地。前端是在一些 JavaScript 的控制下显示页面的浏览器。在 HTML 5 中，前端可能也有一个本地数据库。

### 胖与瘦

一种常见的成分标签是“脂肪”或“瘦”。Fat 组件占用大量内存并进行复杂的处理。另一方面，薄的组件在这两方面都没什么用。似乎没有什么“正常”的尺寸成分，只有胖或瘦！

胖瘦是一个相对的概念。浏览器经常被贴上瘦的标签，因为它们所做的只是显示网页。然而，我的 Linux 机器上的 Firefox 占用了将近半个千兆字节的内存，我一点也不认为这很小！

## 中间件模型

中间件是连接分布式系统组件的“粘合剂”。中间件模型如图 [1-19](#Fig19) 所示。

![A436770_1_En_1_Fig19_HTML.gif](A436770_1_En_1_Fig19_HTML.gif)

图 1-19。

The middleware model

中间件的组件包括以下内容:

*   TCP/IP 等网络服务
*   中间件层是使用网络服务的独立于应用程序的软件
*   数据库访问
*   身份等服务的管理者
*   安全模块

### 中间件示例

中间件的例子包括:

*   终端模拟器、文件传输和电子邮件等基本服务
*   RPC 等基本服务
*   集成服务，如 DCE(分布式计算环境)
*   分布式对象服务，如 CORBA 和 OLE/ActiveX
*   移动对象服务，如 RMI 和 Jini
*   万维网

### 中间件功能

中间件的功能包括:

*   在不同计算机上启动进程
*   会话管理
*   允许客户端定位服务器的目录服务
*   远程数据访问
*   允许服务器处理多个客户端的并发控制
*   安全性和完整性
*   监视
*   本地和远程进程的终止

## 连续加工

Gartner 模型基于将应用程序分解为表示、应用程序逻辑和数据处理等组件。图 [1-20](#Fig20) 显示了更精细的细分。

![A436770_1_En_1_Fig20_HTML.gif](A436770_1_En_1_Fig20_HTML.gif)

图 1-20。

Breakdown of an application into its components of presentation

## 故障点

分布式应用程序运行在复杂的环境中。这使得它们比单台计算机上的独立应用程序更容易失败。故障点包括:

*   客户端错误
    *   应用程序的客户端可能会崩溃
    *   客户端系统可能有硬件问题
    *   客户端的网卡可能会出现故障
*   网络错误
    *   网络连接可能会导致超时
    *   可能存在网络地址冲突
    *   路由器等网络元素可能会出现故障
    *   传输错误可能会丢失消息
*   客户端-服务器错误
    *   客户端和服务器版本可能不兼容
*   服务器错误
    *   服务器的网卡可能会出现故障
    *   服务器系统可能有硬件问题
    *   服务器软件可能会崩溃
    *   服务器的数据库可能会损坏

设计应用程序时必须考虑到这些可能的故障。如果系统的其他部分出现故障，由一个组件执行的任何操作都必须是可恢复的。需要使用诸如事务和连续错误检查之类的技术来避免错误。应该注意的是，虽然独立的应用程序可能对可能发生的错误有很多控制，但分布式系统不是这样。例如，服务器无法控制网络或客户端错误，只能准备处理它们。在许多情况下，错误的原因可能不清楚:是客户端崩溃了还是网络中断了？

## 接受因素

分布式系统的验收因素与独立系统的验收因素相似。它们包括以下内容:

*   可靠性
*   表演
*   响应性
*   可量测性
*   容量
*   安全

目前，用户经常容忍比独立系统更糟糕的行为。“哦，网速慢”似乎是一个可以接受的借口。事实并非如此，开发人员不应该陷入这样的思维定势，认为他们控制下的因素会产生可忽略的影响。

## 透明度

分布式系统的“圣杯”提供以下功能:

*   访问透明性
*   位置透明性
*   迁移透明度
*   复制透明性
*   并发透明性
*   可扩展性透明性
*   绩效透明度
*   故障透明度

### 访问透明性

用户不应知道(或需要知道)对系统的全部或部分的访问是本地的还是远程的。

### 位置透明性

服务的位置并不重要。

### 迁移透明度

如果系统的一部分移动到另一个位置，对用户来说应该没有什么影响。

### 复制透明性

如果系统的一个或多个副本正在运行，应该没有关系。

### 并发透明性

同时运行的系统各部分之间不应有干扰。例如，如果我正在访问数据库，那么你不应该知道。

### 可扩展性透明性

系统上有一百万或一百万用户都没关系。

### 绩效透明度

性能不应受到任何系统或网络特征的影响。

### 故障透明度

该系统不应失败。如果部分失败，系统应该在用户不知道失败发生的情况下恢复。

这些透明度因素中的大多数在违反中比在遵守中观察到的多。有一些显著的例子几乎符合这些标准。例如，当您连接到 Google 时，您不知道(或不关心)服务器在哪里。使用亚马逊网络服务的系统能够根据需求进行伸缩。网飞有着看似残酷的测试策略，定期故意破坏其系统的大部分，以确保整体仍能正常工作。

## 分布式计算的八个谬误

Sun Microsystems 是一家在分布式系统中做了大量早期工作的公司，甚至有一句口头禅“网络就是计算机”。" Sun 的一些科学家根据他们多年的经验，提出了以下通常假定的谬误:

1.  网络是可靠的。
2.  延迟为零。
3.  带宽是无限的。
4.  网络很安全。
5.  拓扑不会改变。
6.  有一个管理员。
7.  运输成本为零。
8.  网络是同构的。

### 谬论:网络可靠

Bailis 和 Kingsbury 的一篇题为“网络是可靠的”(见 [`http://queue.acm.org/detail.cfm?id=2655736`](http://queue.acm.org/detail.cfm?id=2655736) )的论文检验了这一谬误。它发现了许多实例，例如微软报告他们的数据中心每天发生 5.2 次设备故障和 40.8 次链路故障。

中国政府使用“DNS 中毒”作为审查其认为不受欢迎的网站的技术之一。中国也运行一个 DNS 根服务器。2010 年，这台服务器配置错误，毒害了许多其他国家的 DNS 服务器。这使得许多非中文网站在中国内外都无法访问(见 [`http://www.pcworld.com/article/192658/article.html`](http://www.pcworld.com/article/192658/article.html) )。

还有许多其他可能的情况，例如使网站不可用的 DDS(分布式拒绝服务)攻击。在 Box Hill Institute，一个承包商曾经在连接我们的 DHCP 服务器和网络其余部分的光缆上开了一个反孔，于是我们就回家休息了。

网络不可靠。这意味着任何网络程序都必须准备好应对失败。这导致了 Java 的 RMI 和大多数后来的框架的设计选择，应用程序设计允许每个网络调用可能失败。

### 谬误:延迟为零

等待时间是发送信号和得到回复之间的延迟。在单进程系统中，延迟可能取决于函数调用返回之前在函数调用中执行的计算量，但在网络上，延迟通常是由简单地必须遍历传输并由途中的各种节点(如路由器)处理而引起的。

`ping`命令是显示延迟的好方法。从墨尔本到谷歌的澳大利亚服务器需要 20 毫秒。对百度中国服务器的一次 ping 大约需要 200 毫秒 [<sup>1</sup>](#Fn1) 。

相比之下，Williams(参见 [`http://www.eetimes.com/document.asp?doc_id=1200916`](http://www.eetimes.com/document.asp?doc_id=1200916) )讨论了 Linux 调度程序的延迟，得出平均延迟为 88 微秒。网络调用的延迟要大几千倍。

### 谬误:带宽是无限的

每个在下载发生时去沏杯茶或咖啡的人都知道这是一个谬论。我运行自己的网络服务器，在 ADSL2 上获得 800 Kbps 的上传速度。我很不幸，家里有 HFC，灾难性的澳大利亚国家宽带网络可能会将它升级到 1000 Kbps。三年后，到 2020 年。

与此同时，我使用本地无线连接，给我 75 Mbps 上下，它仍然不够快！

### 谬论:网络安全

科技公司大力推动将强大的加密技术用于所有网络通信，世界各国政府也同样大力推动“仅针对特定政府”的较弱系统或后门。这似乎同样适用于民主(我的意外拼写错误可能是准确的！)以及极权政府。

当然，除此之外，还有一般的“坏人”，窃取并出售数百万张信用卡号码和密码。

### 谬误:拓扑不会改变

确实如此。通常，这可能会影响延迟和带宽。但是路由或 IP 地址的硬编码越多，网络应用就越容易出故障。

### 谬误:只有一个管理员

那又怎样？一切正常的时候没问题。出了问题，问题就开始了——该怪谁，该由谁来解决？

多年来的一个主要研究课题是网格计算，它将计算任务分配给许多大学和研究机构来解决巨大的科学问题。这必须解决许多复杂的问题，因为不仅有多个管理员，而且还有不同的访问和安全问题、不同的维护计划等等。云计算的出现解决了许多这样的问题，减少了管理员和系统的数量，因此云计算比许多网格系统更有弹性。

### 谬论:运输成本为零

一旦我买了我的电脑，从 CPU 到显示器的传输成本是零(嗯，小电！).但是我们每个月都要向我们的 IP 提供商付费，因为他们必须建造服务器机房、铺设电缆等等。这只是一个必须考虑的成本。

### 谬误:网络是同质的

网络不是同质的，终端也不是，比如你和我的电脑、iPads、Android 设备和手机。更不用说物联网将无数互联设备带入画面。供应商不断尝试产品锁定，不断限制工作环境，试图简化他们的控制系统，这在一定程度上取得了成功。但当它们失败时，依赖同质性的系统也会失败。

## 结论

本章试图强调，与其他类型的计算相比，分布式计算有其独特的特点。忽视这些特征只会导致最终系统的失败。不断有人试图简化架构模型，最新的是“微服务”和“无服务器”计算，但最终复杂性仍然存在。

这些必须使用任何编程语言来解决，后续章节将考虑 Go 如何管理它们。

Footnotes [1](#Fn1_source)

从我在澳大利亚墨尔本的位置，我看到平时间

`ping`[`www.google.com.au`T3】](http://www.google.com.au)

`PING google.com.au`(216.58.203.99)56(84)字节的数据。

来自`syd09s15-in-f3.1e100.net (216.58.203.99): icmp_seq=1 ttl=50 time=27.1 ms`的 64 字节

来自`syd09s15-in-f3.1e100.net (216.58.203.99): icmp_seq=2 ttl=50 time=19.7 ms`的 64 字节