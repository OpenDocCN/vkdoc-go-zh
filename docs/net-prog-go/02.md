# 2.Go 语言概述

不断有编程语言被发明出来。有些是高度专业化的，有些是相当通用的，而第三组是为了填补广泛的，但在某种程度上利基领域。Go 创建于 2007 年，于 2009 年公开发布。它旨在成为一种系统编程语言，为生产网络和多处理系统扩充(或取代)C++和其他静态编译语言。

Go 加入了一组现代语言，包括 Rust、Swift、Julia 和其他几种语言。Go 的独特之处在于简单的语法、多个程序单元的快速编译、一种基于“结构化”类型的 O/O 编程形式，当然还有从 C、C++和 Java 的大型程序中吸取的经验教训。

2017 年初的语言流行度列表，如 TIOBE(参见 [`http://www.tiobe.com/tiobe-index/`](http://www.tiobe.com/tiobe-index/) `)`)将 Go 列为目前第 14 大最受欢迎的语言。PYPL(参见 [`http://pypl.github.io/PYPL.html`](http://pypl.github.io/PYPL.html) )排在第 19 位。这与 20 多年前的 Java、Python、C、C++、JavaScript 等语言齐名。

这本书假设你是一个有经验的程序员，在某种程度上有一些或广泛的围棋知识。这可以通过介绍性文本，如 Caleb Doxsey (O'Reilly)的《围棋入门》或 Karl Seguin 的《围棋小百科全书》，或者通过阅读更正式的文档，如位于 [`https://golang.org/ref/spec`](https://golang.org/ref/spec) 的《围棋编程语言规范》。

如果你是一个有经验的程序员，你可以跳过这一章。如果没有，这一章指出了本书中用到的一些围棋知识，但是你应该去别的地方获取必要的背景知识。在 Go 网站的 [`http://golang.org`](http://golang.org) 上有几个教程:

*   入门指南
*   Go 编程语言教程
*   有效围棋
*   GoLang 教程

最好从 Go 编程语言网站安装 Go。在写这篇文章的时候，Go 1.8 刚刚发布。本书中的大多数例子将使用 Go 1.6 运行，有一些指向 Go 1.8 的指针。你实际上不需要安装 Go 来测试程序:Go 有一个“操场”,可以从主页进入，用来运行代码。还有几个 REPL(读取-评估-打印循环)环境，但这些都是第三方的。

这本书主要使用了 Go 标准库中的库和包( [`https://golang.org/pkg/`](https://golang.org/pkg/) )。Go 团队还构建了另一组包作为“子库”，它们通常不像标准库那样支持。这些偶尔会用到。需要使用`go get`命令安装它们。这些包的名字包含一个“x”，比如`golang.org/x/net/ipv4`。

## 类型

有预定义的布尔、数字和字符串类型。数字类型包括`uint32`、`int32`、`float32`和其他大小的数字，以及字节(`uint8`和符文。符文和字符串在第七章[中被广泛讨论，因为国际化的问题在分布式程序中很重要。](07.html)

还有更复杂的类型，将在下面讨论。

### 切片和阵列

数组是单一类型的元素序列。切片是基础数组的片段。围棋中处理切片往往更方便。可以静态创建数组:

```go
var x [128]int

```

或者动态地作为指针:

```go
xp := new([128]int)

```

切片可以与其底层阵列一起创建:

```go
x := make([]int, 50, 100)

```

或者

```go
x := new([100]int)[0:50]

```

这最后两个都是类型`[]int`(如`reflect.TypeOf(x)`所示)。

数组或切片的元素通过它们的索引来访问:

```go
x[1]

```

索引从 0 到`len(x)-1`。

可以通过使用数组或切片的较低(包括)和较高(不包括)索引来获取数组或切片的切片:

```go
a := [5]int{-1, -2, -3, -4, -5}
s := a[1:4]  // s is now [-2, -3, -4]

```

### 结构

结构类似于其他语言中的结构。在第 [4](04.html) 章中，我们考虑数据的序列化，并以下列结构为例:

```go
type Person struct {
        Name  Name
        Email []Email
}

type Name struct {
        Family   string
        Personal string
}

type Email struct {
        Kind    string
        Address string
}

```

复合结构可以声明如下:

```go
person := Person{
                    Name: Name{Family: "Newmarch", Personal: "Jan"},
                    Email: []Email{Email{Kind: "home",
                                                Address: "jan@newmarch.name"},
                                        Email{Kind: "work",
                                                Address: "j.newmarch@boxhill.edu.au"}}}

```

结构字段的可见性由字段名称的第一个字符的大小写控制。如果它是大写的，那么它在声明它的包之外是可见的；如果是小写，就不是。在前面的示例中，所有结构的所有字段都是可见的。

### 两颗北极指极星

指针的行为类似于其他语言中的指针。`*`操作符解引用一个指针，而`&`操作符接受一个变量的地址。Go 简化了指针的使用，这样大部分时间你就不用担心了。我们在本书中最多做的是检查指针值是否是`nil`，这通常意味着一个错误，或者相反，如果一个可能的错误值不是`nil`，如下一节所述。

### 功能

使用 Go 特有的符号来定义函数。在 Go 的声明语法博客中解释了为什么没有使用大家熟悉的 C 语法(或者其他语法)。我们让教科书来解释语法的细节。

每个 Go 程序必须有一个如下声明的`main`函数:

```go
func main() { ... }

```

我们将经常使用如下定义的函数`checkError`:

```go
func checkError(err error) {
        if err != nil {
                fmt.Fprintf(os.Stderr, "Fatal error: %s", err.Error())
                os.Exit(1)
        }
}

```

它接受一个参数，没有返回值。它以小写字母开头，所以它对于声明它的包来说是局部的。

返回值的函数通常会返回一个错误状态和一个实际值，如第 [3](03.html) 章中的函数:

```go
func readFully(conn net.Conn) ([]byte, error) { ... }

```

它将`net.Conn`作为参数，并返回一个字节数组和一个错误状态(如果没有发生错误，则返回`nil`)。

在本书中，没有比这更复杂的定义被使用。

### 地图

映射是一种类型的无序元素组，由另一种类型的键索引。我们在本书中不太使用映射，尽管有一处是在第 [10 章](10.html)中，其中一个 HTTP 请求的字段值可以通过使用字段名作为关键字的映射来访问。

### 方法

Go 不像 Java 这样的语言那样有类。然而，类型可以有与之关联的方法，这些方法的行为类似于更标准的 O/O 语言的方法。

我们将大量使用为各种网络类型定义的方法。这将从下一章的第一个程序开始。例如，类型`IPMask`被定义为一个字节数组:

```go
type IPMask []byte

```

在这种类型上定义了许多函数，例如:

```go
func (m IPMask) Size() (ones, bits int)

```

类型为`IPMask`的变量可以应用方法`Size()`，如下所示:

```go
var m IPMask
...
ones, bits := m.Size()

```

学习如何使用网络相关类型的方法是本书的主要目的。

在本书中，我们不会过多地定义我们自己的方法。这是因为为了说明 Go 库，我们不需要很多自己的复杂类型。一个典型的应用是修饰打印一个类似前面定义的`Person`类型的类型:

```go
func (p Person) String() string {
        s := p.Name.Personal + " " + p.Name.Family
        for _, v := range p.Email {
                s += "\n" + v.Kind + ": " + v.Address
        }
        return s
}

```

在第 [10](10.html) 章中有更广泛的使用，其中使用了许多类型和这些类型上的方法。这是因为当我们构建更现实的系统时，我们确实需要自己的类型。

## 多线程

Go 有一个使用`go`命令启动额外线程的简单机制。在本书中，这就是我们所需要的。这里不需要复杂的任务，比如同步多个线程。

## 包装

Go 程序是从链接包中构建的。任何代码块使用的包都必须通过代码文件头部的`import`语句导入。我们自己的程序被声明在包`main`中。

除了第 10 章之外，这本书里几乎所有的程序都在`main`包里。

大多数包都是从标准库中导入的。有些是从`golang.org/x/net/ipv4`等子库导入的。

## 类型变换

本书中我们唯一需要担心的是字符串到字节数组的转换，反之亦然。要将字符串转换为字节数组，您需要:

```go
var b []byte
b = []byte("string")

```

要将整个数组/切片转换为字符串，请使用以下命令:

```go
var s string

s = string(b[:])

```

## 声明

一个函数或方法将由一组语句组成。这些包括赋值、`if`和`switch`语句、`for`和`while`循环，以及其他一些语句。

除了语法之外，它们在本质上与其他编程语言具有相同的含义。几乎所有的语句类型都将在后面的章节中用到。

## GOPATH(高路径)

有两种组织项目工作空间的方法:将每个项目放在一个共享的工作空间中，或者为每个项目准备一个单独的工作空间。我的偏好是第二种，而显然大多数 Go 程序员的偏好是第一种。

环境变量`GOPATH`支持`go`工具的任何一种方式。这可以设置为一个目录列表(Linux/UNIX 中的一个`:`分隔列表，Windows 中的一个`;`分隔列表，以及 Plan9 中的一个列表)。如果未设置，默认为用户主目录中的目录`go`。

对于`GOPATH`中的每个目录，会有三个子目录——`src`、`pkg`和`bin`。目录`src`通常包含每个包名的一个目录，在这个目录下是这个包的源文件。例如，在第 [10](10.html) 章中，我们有一个完整的 web 服务器，它使用我们定义的`dictionary`和`flashcards`包。`src/flashcards`目录包含文件`FlashCards.go`。

## 运行 Go 程序

Go 程序必须有一个定义包`main`的文件。本书中的大多数程序都是在一个文件中定义的，比如第 [3](03.html) 章中的程序`IP.go`。运行它的最简单方法是从包含该文件的目录中运行:

```go
go run IP.go <IP address>

```

或者，您可以构建一个可执行文件，然后运行它:

```go
go build IP.go
./IP <IP address>

```

需要标准软件包以外的软件包的程序将需要设置`GOPATH`。例如，第 10 章中的程序要求(在 Linux 下):

```go
export GOPATH=$PWD
go run Server.go <port>

```

## 标准库

Go 有一套广泛的标准库。例如，没有 C、Java 或 C++大，但是这些语言已经存在很长时间了。Go 包记录在 [`https://golang.org/pkg/`](https://golang.org/pkg/) 中，我们将在本书中广泛使用它们，特别是`net`、`crypto`和`encoding`包。

此外，在同一个页面上还有一个包的子存储库组。这些不太稳定，但有时会有有用的包，我们偶尔会用到。

除此之外，还有大量用户贡献的包。在本书论述原理的正文中不会用到它们，但实际上你会发现它们中的许多非常有用。最后一章讨论了一些问题。

## 误差值

我们在上一章中讨论过，分布式编程和本地编程的一个主要区别是在执行过程中发生错误的可能性大大增加。局部函数调用可能因为简单的编程错误而失败，例如被零除；可能会发生更细微的错误，如内存不足错误，但它们可能发生的情况通常是可以预测的。

另一方面，几乎所有利用网络的功能都可能因为应用程序无法控制的原因而失败。因此，网络程序充满了错误检查。这是乏味的，但也是必要的。就像操作系统内核代码总是要进行错误检查一样——需要对错误进行管理。

在本书中，我们通常在客户端用适当的消息退出一个有错误的程序，对于服务器，尝试通过断开有问题的连接并继续运行来恢复。

像 C 这样的语言通常通过返回“非法”值(如负整数、空指针)或发出信号来发出错误信号。像 Java 这样的语言会引发异常，这会导致混乱的代码，而且通常会很慢。标准的 Go 函数在函数调用返回的额外参数中给出了一个错误。

例如，在下一章中，我们将讨论`net`包中的函数:

```go
func ResolveIPAddr(net, addr string) (*IPAddr, error)

```

管理这种情况的典型代码是:

```go
addr, err := net.ResolveIPAddr("ip", name)
if err != nil {
        ...
}

```

## 结论

这本书假设你了解 Go 编程语言。本章只是强调了后面章节需要的部分。