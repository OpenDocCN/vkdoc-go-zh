# 六、数据持久化

当您构建真实世界的应用程序时，您可能需要将应用程序数据保存到持久存储中。您可以使用各种 Go 类型定义应用程序的数据模型，尤其是结构。在大多数用例中，您可能需要将应用程序数据保存到数据库中。本章向您展示了如何将应用程序数据持久化到数据库中，如 MongoDB、RethinkDB、InfluxDB 和 PostgreSQL。MongoDB 是一个流行的 NoSQL 数据库，广泛用于许多现代应用程序。RethinkDB 是另一个带有实时功能的 NoSQL 数据库，允许您构建实时 web 应用程序。时间序列数据库正在成为数据管理技术中的下一个大事件，因此本章包括使用 InfluxDB 的方法，这是一个用 Go 编写的流行的时间序列数据库。本章还提供了使用传统 SQL 数据库的方法。

## 6-1.用 MongoDB 持久化数据

### 问题

您希望使用 MongoDB 作为 Go 应用程序的数据库。

### 解决办法

第三方包`mgo`为 Go 提供了一个全功能的 MongoDB 驱动程序，它允许您从 Go 应用程序中使用 MongoDB。`mgo`驱动程序已广泛用于生产 Go 应用。

### 它是如何工作的

MongoDB 是一个流行的 NoSQL 数据库，被广泛用作各种现代应用程序的数据库，包括 web 和移动应用程序。MongoDB 是一个开源文档数据库，它提供了高性能、高可用性和自动伸缩。MongoDB 将数据作为文档存储在一种称为二进制 JSON (BSON)的二进制表示中。简而言之，MongoDB 是 BSON 文档的数据存储。如果您想将 MongoDB 与关系数据库管理系统(RDBMS)进行比较，BSON 文档的集合类似于关系数据库中的数据库表，集合中的单个文档类似于关系数据库中的一行表。因为 MongoDB 将数据存储为文档，所以不能将集合与表进行比较。例如，您可以在一个文档中嵌入文档来实现父子关系，而您可以通过在关系数据库中指定外键来将数据保存在两个单独的表中。甚至 NoSQL 数据库也不支持其数据模型中的约束。像大多数 NoSQL 数据库一样，MongoDB 是一个无模式数据库，这意味着数据库在集合内的每个文档中可以有不同的字段集，并且每个字段可以有不同的类型。要获得关于 MongoDB 的更多细节，以及下载和安装的说明，请访问 MongoDB 网站 [`https://www.mongodb.org/`](https://www.mongodb.org/) 。

Note

NoSQL(通常不仅仅指 SQL)数据库提供了一种存储和检索数据的机制，它提供了一种设计数据模型的方法，而不是关系数据库中使用的表格关系。NoSQL 数据库旨在应对现代应用程序开发挑战，例如以更容易的可伸缩性和更好的性能处理大量数据。与关系数据库相比，NoSQL 数据库可以提供高性能、更好的可伸缩性和更便宜的存储。NoSQL 数据库有不同的类型:文档数据库、图形存储、键/值存储和宽列存储。

第三方包`mgo`，发音为“mango”，提供了对使用 MongoDB 数据库的支持，它的子包`bson`实现了使用 BSON 文档的 BSON 规范。诸如`slice`、`map`和`struct`之类的 Go 类型的值可以保存到 MongoDB 中。当对 MongoDB 执行写操作时，包`mgo`自动将 Go 类型的值序列化为 BSON 文档。在大多数用例中，您可以通过使用结构来定义您的数据模型，并对其执行 CRUD 操作。

#### 安装 mgo

要安装软件包`mgo`，运行以下命令:

```go
go get gopkg.in/mgo.v2

```

这将获取包`mgo`及其子包`bson`。要使用`mgo`包，您必须将`gopkg.in/mgo.v2`添加到导入列表中。

```go
import "gopkg.in/mgo.v2"

```

如果您想使用`bson`包，您必须将`gopkg.in/mgo.v2/bson`添加到导入列表中:

```go
import (        
        "gopkg.in/mgo.v2"
        "gopkg.in/mgo.v2/bson"
)

```

#### 正在连接到 MongoDB

要使用 MongoDB 执行 CRUD 操作，首先要使用函数`Dial`获得一个 MongoDB 会话，如下所示:

```go
session, err := mgo.Dial("localhost")

```

函数`Dial`建立到由`url`参数标识的 MongoDB 服务器集群的连接，并返回指向`mgo.Session`的指针，该指针用于对 MongoDB 数据库执行 CRUD 操作。功能`Dial`支持与服务器集群的连接，如下图所示:

```go
session, err := mgo.Dial("server1.mongolab.com,server2.mongolab.com")

```

您还可以使用函数`DialWithInfo`建立到一个或一个服务器集群的连接，该函数返回`mgo.Session`。此函数允许您使用类型`mgo.DialInfo`向服务器传递定制信息，如下所示:

```go
mongoDialInfo := &mgo.DialInfo{
            Addrs:    []string{"localhost"},
            Timeout:  60 * time.Second,
            Database: "bookmarkdb",
            Username: "shijuvar",
            Password: "password123",
        }   

 session, err := mgo.DialWithInfo(mongoDialInfo)

```

所有会话方法都是并发安全的，因此您可以从多个 goroutines 调用它们。根据通过`mgo.Session`指定的一致性模式执行读取操作。会话的方法`SetMode`用于改变会话对象的一致性模式。有三种类型的可用一致性模式:最终、单调和强。如果没有明确指定一致性模式，默认模式是强模式。在强一致性模式下，将始终使用唯一的连接对主服务器进行读取和写入，以便它们完全一致、有序，并观察最新的数据。

### 使用集合

MongoDB 将数据存储为文档，文档被组织成集合。CRUD 操作是针对一个集合执行的，该集合被映射到包`mgo`中的类型`mgo.Collection`。类型为`mgo.Database`的方法`C`用于创建一个`mgo.Collection`对象。`mgo.Database`类型表示 MongoDB 的命名数据库，它是通过调用类型`mgo.Session`的方法`DB`创建的。

下面的语句创建了一个指向`mgo.Collection`的指针，它表示在`"bookmarkdb"`数据库中名为`"bookmarks"`的 MongoDB 集合。

```go
collection := session.DB("bookmarkdb").C("bookmarks")

```

### 执行 CRUD 操作

一旦获得了一个`Session`，就可以对一个`Collection`值执行 CRUD 操作。让我们编写一个示例程序来演示针对`Collection`值的持久化和读取操作。首先，我们在两个源文件中编写示例程序:`bookmark_store.go`和`main.go`。清单 [6-1](#Par24) 显示了`bookmark_store.go`文件的源代码，该文件包含一个用于定义数据模型的名为`Bookmark`的结构，以及一个为执行 CRUD 操作提供持久化逻辑的结构类型`BookmarkStore`。

```go
package main

import (
        "time"

        "gopkg.in/mgo.v2"
        "gopkg.in/mgo.v2/bson"
)

// Bookmark type represents the metadata of a bookmark.
type Bookmark struct {
        ID                          bson.ObjectId `bson:"_id,omitempty"`
        Name, Description, Location string
        Priority                    int // Priority (1 -5)
        CreatedOn             time.Time
        Tags                        []string
}

// BookmarkStore provides CRUD operations against the collection "bookmarks".
type BookmarkStore struct {
        C *mgo.Collection
}

// Create inserts the value of struct Bookmark into collection.
func (store BookmarkStore) Create(b *Bookmark) error {
        // Assign a new bson.ObjectId
        b.ID = bson.NewObjectId()
        err := store.C.Insert(b)
        return err
}

//Update modifies an existing value of a collection.
func (store BookmarkStore) Update(b Bookmark) error {
        // partial update on MogoDB
        err := store.C.Update(bson.M{"_id": b.ID},
                bson.M{"$set": bson.M{
                        "name":        b.Name,
                        "description": b.Description,
                        "location":    b.Location,
                        "priority":    b.Priority,
                        "tags":        b.Tags,
                }})
        return err
}

// Delete removes an existing value from the collection.
func (store BookmarkStore) Delete(id string) error {
        err := store.C.Remove(bson.M{"_id": bson.ObjectIdHex(id)})
        return err
}

// GetAll returns all documents from the collection.
func (store BookmarkStore) GetAll() []Bookmark {
        var b []Bookmark
        iter := store.C.Find(nil).Sort("priority", "-createdon").Iter()
        result := Bookmark{}
        for iter.Next(&result) {
                b = append(b, result)
        }
        return b
}

// GetByID returns single document from the collection.
func (store BookmarkStore) GetByID(id string) (Bookmark, error) {
        var b Bookmark
        err := store.C.FindId(bson.ObjectIdHex(id)).One(&b)
        return b, err
}

// GetByTag returns all documents from the collection filtering by tags.
func (store BookmarkStore) GetByTag(tags []string) []Bookmark {
        var b []Bookmark
        iter := store.C.Find(bson.M{"tags": bson.M{"$in": tags}}).Sort("priority", "-createdon").Iter()
        result := Bookmark{}
        for iter.Next(&result) {
                b = append(b, result)
        }
        return b
}

Listing 6-1.Data Model and Persistence Logic in bookmark_store.go

```

名为`Bookmark`的结构被声明为示例程序的数据模型。

```go
type Bookmark struct {
        ID                          bson.ObjectId `bson:"_id,omitempty"`
        Name, Description, Location string
        Priority                    int // Priority (1 -5)
        CreatedOn              time.Time
        Tags                        []string
}

```

字段`ID`的类型被指定为`bson.ObjectId`，它是一个 12 字节的值，并且用 BSON 表示法中的`_id`映射这个字段。当您插入一个文档时，您需要为字段`_id`提供一个唯一的值`ObjectId`，作为主键。如果在插入操作期间，文档在其根级别(顶层字段)中不包含字段`_id`，则`mgo`驱动程序通过提供唯一值`ObjectId`来添加字段`_id`。

名为`BookmarkStore`的结构被声明用于提供持久化逻辑，该逻辑使用结构`Bookmark;`进行插入和更新操作，它接受值`it`，对于读取操作，它返回相同类型的值。结构`BookmarkStore`有一个带`type mgo.Collection`的字段`C`。通过访问字段`C`执行所有 CRUD 操作。从源文件`main.go`(见清单 [6-2)，](#Par49)`Collection`对象被提供给`BookmarkStore`值，并通过访问`BookmarkStore`的方法执行 CRUD 操作。

```go
type BookmarkStore struct {
        C *mgo.Collection
}

```

#### 在集合中创建文档

`BookmarkStore`的方法`Create`用于将值插入名为`"bookmarks"`的 MongoDB 集合中。它接受指向`Bookmark`的指针，并使用`Collection`的`Insert`方法将`Bookmark`的值插入到 MongoDB 集合中。当执行插入操作时，包`mgo`自动将 Go 类型的值编码成 BSON 规范。

```go
func (store BookmarkStore) Create(b *Bookmark) error {
        // Assign a new bson.ObjectId
        b.ID = bson.NewObjectId()
        err := store.C.Insert(b)
        return err
}

```

通过调用函数`bson.NewObjectId`生成唯一值`ObjectId`，并将其分配给字段`ID`，该字段在 BSON 文档中标记为字段`_i` d。类型`Collection`的函数`Insert`用于将文档插入到集合中。

#### 更新集合中的文档

类型为`Collection`的函数`Update`用于更新现有文档。方法`Update`从集合中查找与所提供的选择器文档匹配的单个文档，并用所提供的值修改该文档。关键字`"$set"`用于对文档进行部分更新。

```go
func (store BookmarkStore) Update(b Bookmark) error {
        // partial update on MogoDB
        err := store.C.Update(bson.M{"_id": b.ID},
                bson.M{"$set": bson.M{
                        "name":        b.Name,
                        "description": b.Description,
                        "location":    b.Location,
                        "priority":    b.Priority,
                        "tags":        b.Tags,
                }})
        return err
}

```

类型`bson.M`用于为`Collection`的方法`Update`提供值。这个类型是带有`map[string]interface{}`签名的类型`map`的一个方便的别名，对于以本地方式处理 BSON 很有用。每当您想以本机方式处理 BSON 文档时，可以提供`bson.M`的值，这对`Collection`对象的`Update`、`Read`和`Delete`操作很有用。

#### 从集合中删除文档

`Collection`的`Remove`功能用于从集合中删除文档。这里的文档是为给定的`id`移除的。

```go
func (store BookmarkStore) Delete(id string) error {
        err := store.C.Remove(bson.M{"_id": bson.ObjectIdHex(id)})
        return err
}

```

#### 从集合中读取文档

`BookmarkStore`的方法`GetAll`返回集合中的所有文档。`Collection`的`Find`方法用于从集合中查询文档。方法`Find`返回一个指向`mgo.Query`的指针，稍后可以使用函数`One`、`For`、`Iter`或`Tail`来检索文档。

```go
func (store BookmarkStore) GetAll() []Bookmark {
        var b []Bookmark
        iter := store.C.Find(nil).Sort("priority", "-createdon").Iter()
        result := Bookmark{}
        for iter.Next(&result) {
                b = append(b, result)
        }
        return b
}

```

一个`nil`值作为选择器文档被提供给方法`Find`以从集合中获取所有文档。产生的`mgo.Query`值表示对给定选择器文档执行的结果集。使用函数`Sort`，得到的`Query`值可用于根据字段值对文档进行排序。这里，对字段`priority`按升序进行排序操作，对`createdon`按降序进行排序操作。要按降序排序，只需将`"-"`作为字段名的前缀，如下所示的字段`createdon`。

```go
iter := store.C.Find(nil).Sort("priority", "-createdon").Iter()

```

`Query`的方法`Iter`返回一个迭代器，能够迭代所有生成的结果，函数`Next`从结果集中检索下一个文档。

`BookmarkStore`的方法`GetByID`为 BSON 文档中给定的`id (_id`返回单个文档。这里的`id`是作为`string`提供的，因此使用函数`bson.ObjectIdHex`将其转换为`bson.ObjectId`。

```go
func (store BookmarkStore) GetByID(id string) (Bookmark, error) {
        var b Bookmark
        err := store.C.FindId(bson.ObjectIdHex(id)).One(&b)
        return b, err
}

```

在这个例子中，`Collection`中的文档也被查询给定的标签，作为`string`的`slice`，它返回与给定标签匹配的文档。

```go
func (store BookmarkStore) GetByTag(tags []string) []Bookmark {
        var b []Bookmark
        iter := store.C.Find(bson.M{"tags": bson.M{"$in": tags}}).Sort("priority", "-createdon").Iter()
        result := Bookmark{}
        for iter.Next(&result) {
                b = append(b, result)
        }
        return b
}

```

查询操作符`$in`允许您使用匹配值列表中任何值的表达式来过滤文档。这里的`$in`操作符用于过滤`tag`字段中的文档。这里，如果任何给定的标签与字段`tags`匹配，查询将返回所有文档。

让我们重用`bookmark_store.go`的函数对 MongoDB 数据库执行 CRUD 操作。清单 [6-2](#Par49) 显示了源文件`main.go`，它通过提供一个`mgo.Collection`值并调用其方法来创建一个`BookmarkStore`类型的实例。

```go
package main

import (
        "fmt"
        "log"
        "time"

        "gopkg.in/mgo.v2"
)

var store BookmarkStore
var id string

// init will invoke before the function main.
func init() {
        session, err := mgo.DialWithInfo(&mgo.DialInfo{
                Addrs:   []string{"127.0.0.1"},
                Timeout: 60 * time.Second,
        })
        if err != nil {
                log.Fatalf("[MongoDB Session]: %s\n", err)
        }
        collection := session.DB("bookmarkdb").C("bookmarks")

        store = BookmarkStore{
                C: collection,
        }
}

// Create and update documents.
func createUpdate() {
        bookmark := Bookmark{
                Name:        "mgo",
                Description: "Go driver for MongoDB",
                Location:    "https://github.com/go-mgo/mgo",
                Priority:    2,
                CreatedOn:   time.Now(),
                Tags:        []string{"go", "nosql", "mongodb"},
        }
        // Insert a new document.
        if err := store.Create(&bookmark); err != nil {
                log.Fatalf("[Create]: %s\n", err)
        }
        id = bookmark.ID.Hex()
        fmt.Printf("New bookmark has been inserted with ID: %s\n", id)
        // Update an existing document.
        bookmark.Priority = 1
        if err := store.Update(bookmark); err != nil {
                log.Fatalf("[Update]: %s\n", err)
        }
        fmt.Println("The value after update:")
              // Retrieve the updated document
        getByID(id)

        bookmark = Bookmark{
                Name:        "gorethink",
                Description: "Go driver for RethinkDB",
                Location:    "https://github.com/dancannon/gorethink",
                Priority:    3,
                CreatedOn:   time.Now(),
                Tags:        []string{"go", "nosql", "rethinkdb"},
        }
        // Insert a new document.
        if err := store.Create(&bookmark); err != nil {
                log.Fatalf("[Create]: %s\n", err)
        }
        id = bookmark.ID.Hex()
        fmt.Printf("New bookmark has been inserted with ID: %s\n", id)

}

// Get a document by given id.
func getByID(id string) {
        bookmark, err := store.GetByID(id)
        if err != nil {
                log.Fatalf("[GetByID]: %s\n", err)
        }
        fmt.Printf("Name:%s, Description:%s, Priority:%d\n",
                bookmark.Name, bookmark.Description, bookmark.Priority)
}

// Get all documents from the collection.
func getAll() {
        // Layout for formatting dates.
        layout := "2006-01-02 15:04:05"
        // Retrieve all documents.
        bookmarks := store.GetAll()
        fmt.Println("Read all documents")
        for _, v := range bookmarks {
                fmt.Printf("Name:%s, Description:%s, Priority:%d, CreatedOn:%s\n",
                        v.Name, v.Description, v.Priority, v.CreatedOn.Format(layout))
        }
}

// Get documents by tags.
func getByTags() {
        layout := "2006-01-02 15:04:05"
        fmt.Println("Query with Tags - 'go, nosql'")
        bookmarks := store.GetByTag([]string{"go", "nosql"})
        for _, v := range bookmarks {
                fmt.Printf("Name:%s, Description:%s, Priority:%d, CreatedOn:%s\n",
                        v.Name, v.Description, v.Priority, v.CreatedOn.Format(layout))
        }
        fmt.Println("Query with Tags - 'mongodb'")
        bookmarks = store.GetByTag([]string{"mongodb"})
        for _, v := range bookmarks {
                fmt.Printf("Name:%s, Description:%s, Priority:%d, CreatedOn:%s\n",
                        v.Name, v.Description, v.Priority, v.CreatedOn.Format(layout))
        }
}

// Delete an existing document from the collection.
func delete() {
        if err := store.Delete(id); err != nil {
                log.Fatalf("[Delete]: %s\n", err)
        }
        bookmarks := store.GetAll()
        fmt.Printf("Number of documents in the collection after delete:%d\n", len(bookmarks))
}

// main - entry point of the program.
func main() {
        createUpdate()
        getAll()
        getByTags()
        delete()
}

Listing 6-2.Perform CRUD Operations on a MongoDB Collection by Using the Type BookmarkStore, in main.go

```

在调用函数`main`之前执行的函数`init`中，使用函数`DialWithInfo`获得一个`mgo.Sessi` on 值，然后创建一个`mgo.Collection`值以提供类型`BookmarkStore`。`BookmarkStore`的值用于对数据库`"bookmarkdb"`中名为`"bookmarks"`的集合执行 CRUD 操作。

```go
var store BookmarkStore
var id string

func init() {
        session, err := mgo.DialWithInfo(&mgo.DialInfo{
                Addrs:   []string{"127.0.0.1"},
                Timeout: 60 * time.Second,
        })
        if err != nil {
                log.Fatalf("[MongoDB Session]: %s\n", err)
        }
        collection := session.DB("bookmarkdb").C("bookmarks")
        store = BookmarkStore{
                C: collection,
        }
}

```

创建和更新操作在函数`createUpdate`中实现，其中两个文档被插入到集合中，一个现有文档被更新。

```go
func createUpdate() {
        bookmark := Bookmark{
                Name:        "mgo",
                Description: "Go driver for MongoDB",
                Location:    "https://github.com/go-mgo/mgo",
                Priority:    2,
                CreatedOn:   time.Now(),
                Tags:        []string{"go", "nosql", "mongodb"},
        }
        // Insert a new document.
        if err := store.Create(&bookmark); err != nil {
                log.Fatalf("[Create]: %s\n", err)
        }
        id = bookmark.ID.Hex()
        fmt.Printf("New bookmark has been inserted with ID: %s\n", id)
        // Update an existing document.
        bookmark.Priority = 1
        if err := store.Update(bookmark); err != nil {
                log.Fatalf("[Update]: %s\n", err)
        }
        fmt.Println("The value after update:")
        // Retrieve the updated document.
        getByID(id)

        bookmark = Bookmark{
                Name:        "gorethink",
                Description: "Go driver for RethinkDB",
                Location:    "https://github.com/dancannon/gorethink",
                Priority:    3,
                CreatedOn:   time.Now(),
                Tags:        []string{"go", "nosql", "rethinkdb"},
        }
        // Insert a new document.
        if err := store.Create(&bookmark); err != nil {
                log.Fatalf("[Create]: %s\n", err)
        }
        id = bookmark.ID.Hex()
        fmt.Printf("New bookmark has been inserted with ID: %s\n", id)

}

```

函数`getByID`用于通过给定的`id`检索现有文档。这个函数是从函数`createUpdate`中调用的，以获取更新操作后的值。

```go
func getByID(id string) {
        bookmark, err := store.GetByID(id)
        if err != nil {
                log.Fatalf("[GetByID]: %s\n", err)
        }
        fmt.Printf("Name:%s, Description:%s, Priority:%d\n", bookmark.Name, bookmark.Description, bookmark.Priority)
}

```

函数`getAll`从集合中检索所有文档，分别按照`priority`升序和`createdon`降序排序。

```go
func getAll() {
        // Layout for formatting dates.
        layout := "2006-01-02 15:04:05"
        // Retrieve all documents.
        bookmarks := store.GetAll()
        fmt.Println("Read all documents")
        for _, v := range bookmarks {
                fmt.Printf("Name:%s, Description:%s, Priority:%d, CreatedOn:%s\n",
                        v.Name, v.Description, v.Priority, v.CreatedOn.Format(layout))
        }
}

```

函数`getByTags`通过使用`tags`进行过滤来检索文档。MongoDB 查询操作符`$in`用于过滤文档。`BookmarkStore`的功能`GetByTag`执行两次。第一次，它是通过提供标签、`go`和`nosql,`来执行的，因此您将获得提供了任何标签的所有文档；在这里你会得到两份文件。第二次，它通过提供标签`mongodb`来执行，因此您将得到一个文档作为结果，因为只有一个文档具有给定的标签。

```go
func getByTags() {
        layout := "2006-01-02 15:04:05"
        fmt.Println("Query with Tags - 'go, nosql'")
        bookmarks := store.GetByTag([]string{"go", "nosql"})
        for _, v := range bookmarks {
                fmt.Printf("Name:%s, Description:%s, Priority:%d, CreatedOn:%s\n",
                        v.Name, v.Description, v.Priority, v.CreatedOn.Format(layout))
        }
        fmt.Println("Query with Tags - 'mongodb'")
        bookmarks = store.GetByTag([]string{"mongodb"})
        for _, v := range bookmarks {
                fmt.Printf("Name:%s, Description:%s, Priority:%d, CreatedOn:%s\n",
                        v.Name, v.Description, v.Priority, v.CreatedOn.Format(layout))
        }
}

```

函数`delete`用于通过给定的`id`删除已有的文档。

```go
func delete() {
        if err := store.Delete(id); err != nil {
                log.Fatalf("[Delete]: %s\n", err)
        }
        bookmarks, err := store.GetAll()
        if err != nil {
                log.Fatalf("[GetAll]: %s\n", err)
        }
        fmt.Printf("Number of documents in the table after delete:%d\n", len(bookmarks))
}

```

从函数`main`中，调用函数来演示 CRUD 操作。

```go
func main() {
        createUpdate()
        getAll()
        getByTags()
        delete()
}

```

让我们运行示例程序。您应该会看到类似如下的输出:

```go
New bookmark has been inserted with ID: 57809514f7e02124b042281d
The value after update:
Name:mgo, Description:Go driver for MongoDB, Priority:1
New bookmark has been inserted with ID: 57809514f7e02124b042281e
Read all documents
Name:mgo, Description:Go driver for MongoDB, Priority:1, CreatedOn:2016-07-09 11:39:24
Name:gorethink, Description:Go driver for RethinkDB, Priority:3, CreatedOn:2016-07-09 11:39:24
Query with Tags - 'go, nosql'
Name:mgo, Description:Go driver for MongoDB, Priority:1, CreatedOn:2016-07-09 11:39:24
Name:gorethink, Description:Go driver for RethinkDB, Priority:3, CreatedOn:2016-07-09 11:39:24
Query with Tags - 'mongodb'
Name:mgo, Description:Go driver for MongoDB, Priority:1, CreatedOn:2016-07-09 11:39:24
Number of documents in the collection after delete:1

```

## 6-2.用 RethinkDB 保存数据

### 问题

您希望使用 RethinkDB 作为 Go 应用程序的数据库。您还想使用 RethinkDB 的实时功能。

### 解决办法

第三方软件包`gorethink`为 Go 提供了一个全功能的 RethinkDB 驱动程序，允许您从 Go 应用程序中使用 RethinkDB。该软件包还允许您使用 RethinkDB 实时订阅和更改数据馈送。

### 它是如何工作的

RethinkDB 是一个 NoSQL 的、可伸缩的 JSON 数据库，它提供了许多类似于 MongoDB 的功能。RethinkDB 将 JSON 文档组织成表格存储。RethinkDB 中的一个`Table`是 JSON 文档的集合。除了人们熟悉的 NoSQL 数据库的功能之外，RethinkDB 还为其数据库引擎提供了实时功能，从而大大简化了实时 web 应用程序的构建。实时 web 应用程序可以将实时更新推送到客户端应用程序，而不是客户端应用程序定期检查服务器的新更新。当您编写实时应用程序时，这可以提高工作效率。使用 WebSocket 协议的 Go 实现，您可以使您的 web 应用程序成为实时应用程序。通过将这一点与 RethinkDB 数据库的实时功能相结合，您可以创建优秀的实时 web 应用程序。当您的实时 web 应用程序使用 RethinkDB 时，您可以订阅实时变更提要；当数据库中有任何变化时，您可以将这些变化推送到您的客户端应用程序。有关 RethinkDB 的更多详细信息，包括安装说明，请访问网站 [`https://www.rethinkdb.com/`](https://www.rethinkdb.com/) 。

Note

Go 包`golang.org/x/net/websocket`和`github.com/gorilla/websocket`实现了 RFC 6455 ( [`https://tools.ietf.org/html/rfc6455`](https://tools.ietf.org/html/rfc6455) )中指定的 WebSocket 协议的客户端和服务器。

#### 安装 gorethink

要安装软件包`gorethink`，运行以下命令:

```go
go get github.com/dancannon/gorethink

```

要使用包`gorethink`，您必须将`github.com/dancannon/gorethink`添加到导入列表中。

```go
import " github.com/dancannon/gorethink"

```

#### 连接到 RethinkDB

要使用 RethinkDB 执行 CRUD 操作，首先要使用函数`Connect`获得一个 RethinkDB 会话，如下所示:

```go
session, err := gorethink.Connect(r.ConnectOpts{
                Address:  "localhost:28015",
                             Database: "bookmarkdb",
 })

```

要配置连接池，可以在调用函数`Connect`时指定`ConnectOpts`类型的属性，如`MaxIdle`、`MaxOpen`和`Timeout`，如下所示:

```go
session, err := gorethink.Connect(gorethink.ConnectOpts{
                Address:  "localhost:28015",        
                            Database: "bookmarkdb",         
                MaxIdle:  10,
                MaxOpen:  10,
 })

```

您可以通过调用`Session`的方法来更改`MaxIdle`和`MaxOpen`属性，如下所示:

```go
session.SetMaxIdleConns(57)
session.SetMaxOpenConns(5)

```

要连接到具有多个节点的 RethinkDB 服务器群集，可以使用以下语法。当连接到具有多个节点的集群时，查询分布在这些节点中。

```go
session, err := gorethink.Connect(gorethink.ConnectOpts{
    Addresses: []string{"localhost:28015", "localhost:28016"},
    Database: " bookmarkdb",
    AuthKey:  "14daak1cad13dj",
    DiscoverHosts: true,
})

```

`AuthKey`用于保护 RethinkDB 集群。

#### 执行 CRUD 操作

一旦获得了一个`Session`对象，就可以对代表 JSON 文档集合的`Table`执行 CRUD 操作。

让我们编写一个示例程序来演示使用 RethinkDB 的持久化和读操作。让我们在两个源文件中编写示例程序:`bookmark_store.go`和`main.go`。清单 [6-3](#Par85) 显示了`bookmark_store.go`文件的源代码，该文件包含一个用于定义数据模型的名为`Bookmark`的结构，以及一个为针对名为`"bookmarks"`的表执行 CRUD 操作提供持久化逻辑的结构类型`BookmarkStore`。

```go
package main

import (
        "time"

        r "github.com/dancannon/gorethink"
)

// Bookmark type represents the metadata of a bookmark.
type Bookmark struct {
        ID                          string `gorethink:"id,omitempty" json:"id"`
        Name, Description, Location string
        Priority                    int // Priority (1 -5)
        CreatedOn                   time.Time
        Tags                        []string
}

// BookmarkStore provides CRUD operations against the Table "bookmarks".
type BookmarkStore struct {
        Session *r.Session
}

// Create inserts the value of struct Bookmark into Table.
func (store BookmarkStore) Create(b *Bookmark) error {

        resp, err := r.Table("bookmarks").Insert(b).RunWrite(store.Session)
        if err == nil {
                b.ID = resp.GeneratedKeys[0]
        }

        return err
}

// Update modifies an existing value of a Table.
func (store BookmarkStore) Update(b *Bookmark) error {

        var data = map[string]interface{}{
                "name":        b.Name,
                "description": b.Description,
                "location":    b.Location,
                "priority":    b.Priority,
                "tags":        b.Tags,
        }
        // partial update on RethinkDB
        _, err := r.Table("bookmarks").Get(b.ID).Update(data).RunWrite(store.Session)
        return err
}

// Delete removes an existing value from the Table.
func (store BookmarkStore) Delete(id string) error {
        _, err := r.Table("bookmarks").Get(id).Delete().RunWrite(store.Session)
        return err
}

// GetAll returns all documents from the Table.
func (store BookmarkStore) GetAll() ([]Bookmark, error) {
        bookmarks := []Bookmark{}

        res, err := r.Table("bookmarks").OrderBy("priority", r.Desc("date")).Run(store.Session)
        err = res.All(&bookmarks)
        return bookmarks, err
}

// GetByID returns single document from the Table.
func (store BookmarkStore) GetByID(id string) (Bookmark, error) {
        var b Bookmark
        res, err := r.Table("bookmarks").Get(id).Run(store.Session)
        res.One(&b)
        return b, err
}

Listing 6-3.Data Model and Persistence Logic in bookmark_store.go

```

名为`Bookmark`的结构被声明为示例程序的数据模型。

```go
type Bookmark struct {
        ID                          string `gorethink:"id,omitempty" json:"id"`
        Name, Description, Location string
        Priority                    int // Priority (1 -5)
        CreatedOn              time.Time
        Tags                        []string
}

```

结构字段`ID`在文档的 JSON 表示中用 RethinkDB `Table,`的`id`和`id`标记。RethinkDB 将为字段`id`自动生成一个`UUID`。

名为`BookmarkStore`的结构被声明用于提供使用数据模型结构`Bookmark`的持久化逻辑。结构`BookmarkStore`有一个类型为`gorethink.Session`的字段`Session`。所有 CRUD 操作都是通过访问使用字段`Session`的`BookmarkStore`的方法来执行的。

```go
type BookmarkStore struct {
        Session *r.Session
}

```

##### 在表格中创建文档

`BookmarkStore`的方法`Create`用于将值插入名为`bookmarks`的表中。它接受一个指向`Bookmark`的指针，并将`Bookmark`的值插入表中。当执行插入和更新操作时，`gorethink`包在发送到服务器之前将结构值编码到一个`map`中。

```go
func (store BookmarkStore) Create(b *Bookmark) error {

        resp, err := r.Table("bookmarks").Insert(b).RunWrite(store.Session)
        if err == nil {
                b.ID = resp.GeneratedKeys[0]
        }
        return err
}

```

类型`gorethink.Term`表示写和读查询。在包`gorethink`中，方法是可链接的，因此您可以轻松地构造查询。在前面的方法中，函数`Table`和方法`Insert`返回一个`gorethink.Term`值。函数`RunWrite`运行一个查询，然后返回一个`WriteResponse`类型的值。通过访问`WriteResponse`值的`GeneratedKeys`字段，可以得到`id`值。函数`RunWrite`用于执行写查询，如`Insert`、`Update`、`Delete`、`DBCreate`、`TableCreate`等。

##### 更新表格中的文档

为了更新一个现有的文档，提供一个带有签名`map[string]interface{}`的值`map`作为表中要更新的值。

```go
func (store BookmarkStore) Update(b *Bookmark) error {

        var data = map[string]interface{}{
                "name":        b.Name,
                "description": b.Description,
                "location":    b.Location,
                "priority":    b.Priority,
                "tags":        b.Tags,
        }

        // partial update on RethinkDB
        _, err := r.Table("bookmarks").Get(b.ID).Update(data).RunWrite(store.Session)
        return err
}

```

##### 从表格中删除文档

类型为`Term`的方法`Delete`用于运行删除查询，从表中删除现有文档。

```go
func (store BookmarkStore) Delete(id string) error {
        _, err := r.Table("bookmarks").Get(id).Delete().RunWrite(store.Session)
        return err
}

```

##### 从桌上阅读文件

函数`Run`用于运行读取查询。函数`Run`返回一个作为查询结果的`gorethink.Cursor`值。通过使用`One`、`All`、`Next`和`NextResponse`等方法，您可以将文档检索到您的 Go 类型中。类型为`BookmarkStore`的方法`GetAll`从`bookmarks`表中返回所有文档，该表按`priority`升序和`createdon`降序排序。默认情况下，排序是按升序执行的，所以如果您想按降序排序，可以使用函数`Desc`。

```go
func (store BookmarkStore) GetAll() ([]Bookmark, error) {
        bookmarks := []Bookmark{}
        res, err := r.Table("bookmarks").OrderBy("priority", r.Desc("createdon")).Run(store.Session)
        err = res.All(&bookmarks)
        return bookmarks, err
}

```

类型为`BookmarkStore`的方法`GetByID`为给定的`id`返回一个文档。

```go
func (store BookmarkStore) GetByID(id string) (Bookmark, error) {
        var b Bookmark
        res, err := r.Table("bookmarks").Get(id).Run(store.Session)
        res.One(&b)
        return b, err
}

```

让我们重用`bookmark_store.go`的函数来对 RethinkDB `Table`执行 CRUD 操作。清单 [6-4](#Par103) 显示了`main.go`文件中的源代码，它通过提供一个`gorethink.Session`值来创建一个`BookmarkStore`类型的实例，并调用其方法来执行 CRUD 操作。这个`main.go`还通过订阅表的变更提要来提供 RethinkDB 实时功能的实现。

```go
package main

import (
        "fmt"
        "log"
        "time"

        r "github.com/dancannon/gorethink"
)

var store BookmarkStore
var id string

// initDB creates new database and
func initDB(session *r.Session) {
        var err error
        // Create Database
        _, err = r.DBCreate("bookmarkdb").RunWrite(session)
        if err != nil {
                log.Fatalf("[initDB]: %s\n", err)
        }
        // Create Table
        _, err = r.DB("bookmarkdb").TableCreate("bookmarks").RunWrite(session)
        if err != nil {
                log.Fatalf("[initDB]: %s\n", err)
        }
}

// changeFeeds subscribes real-time changes on table bookmarks.
func changeFeeds(session *r.Session) {
        bookmarks, _ := r.Table("bookmarks").Changes().Field("new_val").Run(session)
               if err != nil {
                log.Fatalf("[changeFeeds]: %s\n", err)
        }

        // Launch a goroutine to print real-time updates.
        go func() {
                var bookmark Bookmark
                for bookmarks.Next(&bookmark) {
                        if bookmark.ID == "" { // for delete, new_val will be null.
                                fmt.Println("Real-time update: Document has been deleted")
                        } else {
                                fmt.Printf("Real-time update: Name:%s, Description:%s, Priority:%d\n",
                                        bookmark.Name, bookmark.Description, bookmark.Priority)
                        }
                }
        }()
}

// init will invoke before the function main
func init() {
        session, err := r.Connect(r.ConnectOpts{
                Address:  "localhost:28015",
                Database: "bookmarkdb",
                MaxIdle:  10,
                MaxOpen:  10,
        })

        if err != nil {
                log.Fatalf("[RethinkDB Session]: %s\n", err)
        }

        // Create Database and Table.
        initDB(session)
        store = BookmarkStore{
                Session: session,
        }
        // Subscribe real-time changes
        changeFeeds(session)
}

// Create and update documents.
func createUpdate() {
        bookmark := Bookmark{
                Name:        "mgo",
                Description: "Go driver for MongoDB",
                Location:    "https://github.com/go-mgo/mgo",
                Priority:    1,
                CreatedOn:   time.Now(),
                Tags:        []string{"go", "nosql", "mongodb"},
        }
        // Insert a new document.
        if err := store.Create(&bookmark); err != nil {
                log.Fatalf("[Create]: %s\n", err)
        }
        id = bookmark.ID
        fmt.Printf("New bookmark has been inserted with ID: %s\n", id)
        // Update an existing document.
        bookmark.Priority = 2
        if err := store.Update(bookmark); err != nil {
                log.Fatalf("[Update]: %s\n", err)
        }
        fmt.Println("The value after update:")
        // Retrieve the updated document.
        getByID(id)
        bookmark = Bookmark{
                Name:        "gorethink",
                Description: "Go driver for RethinkDB",
                Location:    "https://github.com/dancannon/gorethink",
                Priority:    1,
                CreatedOn:   time.Now(),
                Tags:        []string{"go", "nosql", "rethinkdb"},
        }
        // Insert a new document.
        if err := store.Create(&bookmark); err != nil {
                log.Fatalf("[Create]: %s\n", err)
        }
        id = bookmark.ID
        fmt.Printf("New bookmark has been inserted with ID: %s\n", id)

}

// Get a document by given id.
func getByID(id string) {
        bookmark, err := store.GetByID(id)
        if err != nil {
                log.Fatalf("[GetByID]: %s\n", err)
        }
        fmt.Printf("Name:%s, Description:%s, Priority:%d\n", bookmark.Name, bookmark.Description, bookmark.Priority)
}

// Get all documents from bookmarks table.
func getAll() {
        // Layout for formatting dates.
        layout := "2006-01-02 15:04:05"
        // Retrieve all documents.
        bookmarks, err := store.GetAll()
        if err != nil {
                log.Fatalf("[GetAll]: %s\n", err)
        }
        fmt.Println("Read all documents")
        for _, v := range bookmarks {
                fmt.Printf("Name:%s, Description:%s, Priority:%d, CreatedOn:%s\n", v.Name, v.Description, v.Priority, v.CreatedOn.Format(layout))
        }

}

// Delete an existing document from bookmarks table.
func delete() {
        if err := store.Delete(id); err != nil {
                log.Fatalf("[Delete]: %s\n", err)
        }
        bookmarks, err := store.GetAll()
        if err != nil {
                log.Fatalf("[GetAll]: %s\n", err)
        }
        fmt.Printf("Number of documents in the table after delete:%d\n", len(bookmarks))
}

// main - entry point of the program
func main() {
        createUpdate()
        getAll()
        delete()
}

Listing 6-4.Perform CRUD Operations on a RethinkDB Table Using the Type BookmarkStore, in main.go

```

在`init`函数中，通过使用函数`Connect`连接到 RethinkDB 服务器来获得一个`Session`值。与 MongoDB 不同，在 RethinkDB 中，您必须手动创建数据库和表。从 Go 代码本身，通过调用函数`initDB`创建一个名为`bookmarkdb`的数据库和一个名为`bookmarks`的表。如果你多次执行函数`initDB`，你会得到一个异常。用于演示 RethinkDB 实时功能的函数`changeFeeds`也是从`init`中调用的。我们将在本节稍后研究函数`changeFeeds`。函数`init`将在函数`main`之前被调用。

```go
func init() {
        session, err := r.Connect(r.ConnectOpts{
                Address:  "localhost:28015",
                Database: "bookmarkdb",
                MaxIdle:  10,
                MaxOpen:  10,
        })

        if err != nil {
                log.Fatalf("[RethinkDB Session]: %s\n", err)
        }

        // Create Database and Table.
        initDB(session)
        store = BookmarkStore{
                Session: session,
        }
        // Subscribe real-time changes
        changeFeeds(session)
}

```

创建和更新操作在函数`createUpdate`中实现，其中两个文档被插入到`bookmarks`表中，一个现有文档被更新。

```go
func createUpdate() {
        bookmark := Bookmark{
                Name:        "mgo",
                Description: "Go driver for MongoDB",
                Location:    "https://github.com/go-mgo/mgo",
                Priority:    1,
                CreatedOn:   time.Now(),
                Tags:        []string{"go", "nosql", "mongodb"},
        }
        // Insert a new document.
        if err := store.Create(&bookmark); err != nil {
                log.Fatalf("[Create]: %s\n", err)
        }
        id = bookmark.ID
        fmt.Printf("New bookmark has been inserted with ID: %s\n", id)
        // Update an existing document.
        bookmark.Priority = 2
        if err := store.Update(bookmark); err != nil {
                log.Fatalf("[Update]: %s\n", err)
        }
        fmt.Println("The value after update:")
        // Retrieve the updated document.
        getByID(id)
        bookmark = Bookmark{
                Name:        "gorethink",
                Description: "Go driver for RethinkDB",
                Location:    "https://github.com/dancannon/gorethink",
                Priority:    1,
                CreatedOn:   time.Now(),
                Tags:        []string{"go", "nosql", "rethinkdb"},
        }
        // Insert a new document.
        if err := store.Create(&bookmark); err != nil {
                log.Fatalf("[Create]: %s\n", err)
        }
        id = bookmark.ID
        fmt.Printf("New bookmark has been inserted with ID: %s\n", id)
}

```

函数`getByID`用于通过给定的`id`检索现有文档。这个函数从函数`createUpdate`中被调用，以在更新操作后获取值。

```go
func getByID(id string) {
        bookmark, err := store.GetByID(id)
        if err != nil {
                log.Fatalf("[GetByID]: %s\n", err)
        }
        fmt.Printf("Name:%s, Description:%s, Priority:%d\n", bookmark.Name, bookmark.Description, bookmark.Priority)
}

```

函数`getAll`分别从按照`priority`升序和`createdon`降序排序的表中检索所有文档。

```go
func getAll() {
        // Layout for formatting dates.
        layout := "2006-01-02 15:04:05"
        // Retrieve all documents.
        bookmarks, err := store.GetAll()
        if err != nil {
                log.Fatalf("[GetAll]: %s\n", err)
        }
        fmt.Println("Read all documents")
        for _, v := range bookmarks {
                fmt.Printf("Name:%s, Description:%s, Priority:%d, CreatedOn:%s\n", v.Name, v.Description, v.Priority, v.CreatedOn.Format(layout))
        }

}

```

函数`delete`用于通过给定的`id`删除现有的文档。

```go
func delete() {
        if err := store.Delete(id); err != nil {
                log.Fatalf("[Delete]: %s\n", err)
        }
        bookmarks, err := store.GetAll()
        if err != nil {
                log.Fatalf("[GetAll]: %s\n", err)
        }
        fmt.Printf("Number of documents in the table after delete:%d\n", len(bookmarks))
}

```

从函数`main`中，调用函数来演示 CRUD 操作。

```go
func main() {
        createUpdate()
        getAll()
        delete()
}

```

#### RethinkDB 中的更改源

RethinkDB 的实时功能是使用`Changefeeds`实现的，它允许 RethinkDB 数据库的客户端实时接收对表的更改。使用`gorethink`驱动程序，您可以通过对`Table`值调用函数`Changes`来订阅变更数据的提要。在清单 [6-4](#Par103) 中，`main.go`中的函数`changeFeeds`实现了 RethinkDB 的`Changefeeds`来订阅表`bookmarks`上的数据，以便应用程序可以在表`bookmarks`上执行任何插入、更新或删除操作时接收这些提要。

```go
func changeFeeds(session *r.Session) {
        bookmarks, _ := r.Table("bookmarks").Changes().Field("new_val").Run(session)
               if err != nil {
                log.Fatalf("[changeFeeds]: %s\n", err)
        }
        // Launch a goroutine to print real-time updates.
        go func() {
                var bookmark Bookmark
                for bookmarks.Next(&bookmark) {
                        if bookmark.ID == "" {  // for delete, new_val will be null.
                                fmt.Println("Real-time update: Document has been deleted")
                        } else {
                                fmt.Printf("Real-time update: Name:%s, Description:%s, Priority:%d\n",
                                        bookmark.Name, bookmark.Description, bookmark.Priority)
                        }
                }
        }()
}

```

调用函数`Changes`来订阅字段`new_val`的重新思考数据库的`Changefeeds`。当对表执行任何更新时，`Changefeeds`功能可以提供两个值:`old_val`和`new_val`。`old_val`是文档的旧版本，而`new_val`是文档的新版本。在 insert 上，`old_val`将是`null`；在删除时，`new_val`将成为`null`。更新时，`old_val`和`new_val`都存在。在功能`changeFeeds`中，订阅了`new_val`。可以在处理函数中订阅`Changefeeds`的输出，以对`Changefeeds`提供的值执行操作。这里，处理函数是在一个 goroutine 中实现的，因此它将在后台异步执行，而不会阻塞任何执行。通过与 goroutines 和 channels 结合，您可以使用 Go 和 RethinkDB 创建高效的实时应用程序。这里，控制台窗口中打印出字段`new_val`结果的`Changefeeds`。对于删除操作，`new_val`将是`null`,这样您就不会在删除操作中访问`Changefeeds`的任何值。当对表`bookmarks`执行任何插入、更新或删除操作时，`Changefeeds`功能将提供提要。通过执行`Run`，可从函数`Changes`提供的`Cursor`值访问`Changefeeds`的`new_val`值。通过调用`Cursor` value 的函数`Next`，可以检索`Changefeeds`提供的值。

让我们运行清单 [6-4](#Par103) 中编写的程序。您应该会看到类似如下的输出:

```go
Real-time update: Name:mgo, Description:Go driver for MongoDB, Priority:1
New bookmark has been inserted with ID: f487b133-6f19-4b3b-8dfa-4d652b2f1c1b
Real-time update: Name:mgo, Description:Go driver for MongoDB, Priority:2
The value after update:
Name:mgo, Description:Go driver for MongoDB, Priority:2
Real-time update: Name:gorethink, Description:Go driver for RethinkDB, Priority:1
New bookmark has been inserted with ID: ee6a19c8-efa5-4672-ae62-37d8b0ea060f
Read all documents
Name:gorethink, Description:Go driver for RethinkDB, Priority:1, CreatedOn:2016-07-08 20:03:50
Name:mgo, Description:Go driver for MongoDB, Priority:2, CreatedOn:2016-07-08 20:03:49
Real-time update: Document has been deleted
Number of documents in the table after delete:1

```

输出显示`Changefeeds`功能提供了对表书签的实时更新。

## 6-3.使用 InfluxDB 处理时间序列数据

### 问题

您希望使用时间序列数据来构建时间序列图表和实时数据分析。

### 解决办法

InfluxDB 是一个用 Go 编写的时间序列数据库。InfluxDB 提供了一个本地 Go 客户端库(`github.com/influxdata/influxdb/client/v2`)来处理来自 Go 应用程序的 InfluxDB。

### 它是如何工作的

时间序列数据处理和实时数据分析是大数据和数据管理技术的下一件大事。InfluxDB 是 InfluxData 平台的一部分，是一个时间序列数据库，允许您有效地存储时间序列数据。InfluxDB 包括一个本地 Go 客户端库，它提供了读写时间序列数据的便利函数。它使用 HTTP 协议与您的 InfluxDB 集群通信。

#### 时间序列数据库

时间序列数据是一系列数据点，通常由一段时间间隔内的连续测量值组成。当您基于时间序列数据构建图表时，其中一个轴将始终是时间(年、日、小时、分钟)。时间序列数据处理是建立预测模型和预测的重要数据管理方法。时序数据库(TSDB)是一种用于管理和存储时序数据的数据库。InfluxDB 由 InfluxData 平台提供，是市场上最流行的 TSDBs 之一。

#### 主要概念 InfluxDB

InfluxDB 中的数据管理不同于传统的数据管理系统。以下是 InfluxDB 中关键概念的总结:

*   数据库:InfluxDB 中的高层实体。一个 InfluxDB 实例中可以有多个数据库。
*   度量:将时间序列数据保存到度量中。度量类似于关系表。当您基于时间序列数据构建图形时，测量值就是图形的名称。
*   点:度量包含点，就像关系表包含记录一样。点包含强制字段和时间戳。时间戳指定该点的时间，并且字段用于存储该时间戳的数据。一个点可以有标签，标签是时间序列数据的元数据。
*   时间戳:度量中的每个点都包含一个时间戳，因为 InfluxDB 是一个 TSDB。如果在创建新点时没有提供时间戳，InfluxDB 会自动为该点创建一个新的时间戳。点中的时间戳指定了它的创建时间。构建图表时，一个轴是时间，另一个轴是字段的值。
*   字段集:字段的集合称为字段集。
*   标签:点中的标签是被索引的元数据。请记住，测量是在标签上索引的，而不是在字段上。
*   标签集:所有标签的集合称为标签集。
*   系列:测量和标签的组合称为系列。

#### 线路协议

线路协议是一种基于文本的格式，用于在 InfluxDB 中写入测量点。它由测量值、标签、字段和时间戳组成。当您使用 InfluxDB 的 HTTP API 向 InfluxDB 写入指针时，HTTP POST 的主体将是一个 line 协议，它表示要插入到 InfluxDB 的时序数据。线路协议中的每条线路定义一个点。多行必须用换行符`\n`隔开。线路协议的格式由三部分组成:

```go
 [key] [fields] [timestamp]

```

线路协议中的每个部分都由空格分隔。它必须提供测量名称和至少一个字段。标签是可选的，但是在现实世界中，您应该包含标签。标记键和标记值是字符串。字段键是字符串，默认情况下，字段值是浮点数。如果一个点不包含时间戳，它将使用服务器的本地纳秒时间戳写入。除非提供了精度值，否则时间戳假定为纳秒。以下是代表单点的线路协议:

```go
cpu,host=server01,region=uswest cpu_usage=46.26 1434055562000000000

```

这里`cpu`是`measurement`的名字，`host`和`region`是`tags`的`keys`,`cpu_usage`是`field`的名字，其`value`为 46.26。`value 1434055562000000000`就是`timestamp`。当您使用 Go 客户端库将记录写入 InfluxDB 时，您不需要使用 line 协议格式制作数据，因为这是由客户端库完成的。

#### 安装 InfluxDB

建议您使用 [`https://www.influxdata.com/downloads/#influxdb`](https://www.influxdata.com/downloads/#influxdb) 中的一个预构建包来安装 InfluxDB。你也可以从 [`https://github.com/influxdata/influxdb`](https://github.com/influxdata/influxdb) 安装 InfluxDB。

在 macOS 中，您可以使用 brew 安装 InfluxDB:

```go
brew install influxdb

```

#### 在 InfluxDB 中创建数据库

让我们使用其命令行界面`influx`在 InfluxDB 中创建一个数据库和用户帐户。`influx`工具为数据库提供了一个交互式的 shell 来写数据，交互式地查询数据，以及查看不同格式的查询输出。要启动 InfluxDB 命令行界面，运行命令`influx`:

```go
$ influx

```

下一个命令创建一个名为`opsadmin`的用户帐户:

```go
> create user opsadmin with password 'pass123'

```

该命令向新创建的用户`opsadmin`授予权限:

```go
> grant all privileges to opsadmin

```

最后一个命令创建了一个名为`metricsdb`的数据库

```go
> create database metricsdb

```

#### 使用 Go 客户端处理 InfluxDB

InfluxDB 的 Go 客户端库的`v2`版本从`github.com/influxdata/influxdb/client/v2`开始提供。Go 客户端库由 InfluxDB 团队维护。要安装软件包的`v2`版本，请运行以下命令:

```go
go get github.com/influxdata/influxdb/client/v2

```

要使用该包，您必须将`github.com/influxdata/influxdb/client/v2`添加到导入列表中。

```go
import "github.com/influxdata/influxdb/client/v2"

```

##### 正在连接到英菲尼克斯数据库

默认情况下，InfluxDB 侦听端口 8086。以下代码块使用用户帐户`opsadmin`连接到 InfluxDB。

```go
c, err := client.NewHTTPClient(client.HTTPConfig{
                Addr:     "http://localhost:8086",
                Username: “opsadmin”,
                Password: “pass123”,
        })

```

函数`NewHTTPClient`从给定的配置中返回一个新的 InfluxDB `Client`。结构类型`HTTPConfig`用于为创建 InfluxDB `Client`提供配置。下面是 struct `HTTPConfig`的定义:

```go
// HTTPConfig is the config data needed to create an HTTP Client
type HTTPConfig struct {
        // Addr should be of the form "http://host:port"
        // or "http://[ipv6-host%zone]:port".
        Addr string

        // Username is the influxdb username, optional
        Username string

        // Password is the influxdb password, optional
        Password string

        // UserAgent is the http User Agent, defaults to "InfluxDBClient"
        UserAgent string

        // Timeout for influxdb writes, defaults to no timeout
        Timeout time.Duration

        // InsecureSkipVerify gets passed to the http client, if true, it will
        // skip https certificate verification. Defaults to false
        InsecureSkipVerify bool

        // TLSConfig allows the user to set their own TLS config for the HTTP
        // Client. If set, this option overrides InsecureSkipVerify.
        TLSConfig *tls.Config
}

```

一旦创建了 InfluxDB `Client`，就可以使用它进行写和查询操作。

##### 写入指向 InfluxDB 的点

当您向`measurement`写入指针以将数据持久化到 InfluxDB 中时，您应该成批地这样做。要批量写入点，首先创建一个新的`BatchPoints`值，如下所示:

```go
bp, err := client.NewBatchPoints(client.BatchPointsConfig{
                Database:  “metricsdb”,
                Precision: "s",
        })

```

通过提供配置来创建一个`BatchPoints`值。属性`Precision`指定为每个`point`创建的`timestamp`的精度。默认情况下，Unix 中的所有时间戳都以纳秒为单位。如果您想以纳秒以外的任何单位提供时间戳，您必须提供适当的精度。分别用`n`、`u`、`ms`、`s`、`m`和`h`表示纳秒、微秒、毫秒、秒、分和小时。

下面的代码块通过向名为`cpu`的`measurement`提供`tags`、`fields`和`timestamp`的值来创建一个新的`point`。

```go
// tagset – “host” and “region”
tags := map[string]string{
 "host":   "host1"
 "region": "us-west"
}

// field - "cpu_usage"
fields := map[string]interface{}{
 "cpu_usage": 46.22
}

// New point to measurement named “cpu”
pt, err := client.NewPoint("cpu ", tags, fields, time.Now())

 if err != nil {
       log.Fatalln("Error: ", err)
}

bp.AddPoint(pt)

```

因为你是批量写点的，所以用函数`AddPoint`把`n`的点数加到`BatchPoints`上。一旦所有的点都添加到`BatchPoints`中，调用 InfluxDB `Client`实例的函数`Write`来完成写操作。

```go
// Write the batch
c.Write(bp) // c is the instance of InfluxDB Client instance

```

##### 从 InfluxDB 读取点

InfluxDB 提供了使用熟悉的 SQL 结构查询数据的能力。该代码块决定了`measurement cpu`中点的`count`值。

```go
command:= fmt.Sprintf("SELECT count(%s) FROM %s", "cpu_usage", "cpu")
q := client.Query{
                Command:  command,
                Database: DB,
        }
        // Query the Database
        if response, err := c.Query(q)  // // c is the instance of InfluxDB Client instance
        if err != nil {
              log.Fatalln("Error: ", err)
        }
        count :=response.Results[0].Series[0].Values[0][1]

```

##### 示例:在 InfluxDB 上读写

清单 [6-5](#Par170) 显示了一个示例程序，它将点批量写入 InfluxDB，并从数据库中读取点。

```go
package main

import (
        "encoding/json"
        "fmt"
        "log"
        "math/rand"
        "time"

        client "github.com/influxdata/influxdb/client/v2"
)

const (
        // DB provides the database name of the InfluxDB
        DB       = "metricsdb"
        username = "opsadmin"
        password = "pass123"
)

func main() {
        // Create client
        c := influxDBClient()
        // Write operations
        // Create metrics data for measurement "cpu"
        createMetrics(c)
        // Read operations
        // Read with limit of 10
        readWithLimit(c, 10)
        // Read mean value of "cpu_usage" for a region
        meanCPUUsage(c, "us-west")
        // Read count of records for a region
        countRegion(c, "us-west")

}

// influxDBClient returns InfluxDB Client
func influxDBClient() client.Client {
        c, err := client.NewHTTPClient(client.HTTPConfig{
                Addr:     "http://localhost:8086",
                Username: username,
                Password: password,
        })
        if err != nil {
                log.Fatalln("Error: ", err)
        }
        return c
}

// createMetrics write batch points to create the metrics data
func createMetrics(clnt client.Client) {
        batchCount := 100
        rand.Seed(42)

        // Create BatchPoints by giving config for InfluxDB
        bp, _ := client.NewBatchPoints(client.BatchPointsConfig{
                Database:  DB,
                Precision: "s",
        })
        // Batch update to adds Points
        for i := 0; i < batchCount; i++ {
                regions := []string{"us-west", "us-central", "us-north", "us-east"}
                // tagset – “host” and “region”
                tags := map[string]string{
                        "host":   fmt.Sprintf("192.168.%d.%d", rand.Intn(100), rand.Intn(100)),
                        "region": regions[rand.Intn(len(regions))],
                }

                value := rand.Float64() * 100.0
                // field - "cpu_usage"
                fields := map[string]interface{}{
                        "cpu_usage": value,
                }

                pt, err := client.NewPoint("cpu", tags, fields, time.Now())

                if err != nil {
                        log.Fatalln("Error: ", err)
                }
                // Add a Point
                bp.AddPoint(pt)

        }
        // Writes the batch update to add points to measurement "cpu"
        err := clnt.Write(bp)
        if err != nil {
                log.Fatalln("Error: ", err)
        }
}

// queryDB query the database
func queryDB(clnt client.Client, command string) (res []client.Result, err error) {
        // Create the query
        q := client.Query{
                Command:  command,
                Database: DB,
        }
        // Query the Database
        if response, err := clnt.Query(q); err == nil {
                if response.Error() != nil {
                        return res, response.Error()
                }
                res = response.Results
        } else {
                return res, err
        }
        return res, nil
}

// readWithLimit reads records with a given limit
func readWithLimit(clnt client.Client, limit int) {
        q := fmt.Sprintf("SELECT * FROM %s LIMIT %d", "cpu", limit)
        res, err := queryDB(clnt, q)
        if err != nil {
                log.Fatalln("Error: ", err)
        }

        for i, row := range res[0].Series[0].Values {
                t, err := time.Parse(time.RFC3339, row[0].(string))
                if err != nil {
                        log.Fatalln("Error: ", err)
                }
                val, err := row[1].(json.Number).Float64()
                fmt.Printf("[%2d] %s: %f\n", i, t.Format(time.Stamp), val)
        }
}

// meanCPUUsage reads the mean value of cpu_usage
func meanCPUUsage(clnt client.Client, region string) {
        q := fmt.Sprintf("select mean(%s) from %s where region = '%s'", "cpu_usage", "cpu", region)
        res, err := queryDB(clnt, q)
        if err != nil {
                log.Fatalln("Error: ", err)
        }
        value, err := res[0].Series[0].Values[0][1].(json.Number).Float64()
        if err != nil {
                log.Fatalln("Error: ", err)
        }

        fmt.Printf("Mean value of cpu_usage for region '%s':%f\n", region, value)
}

// countRegion reads the count of records for a given region
func countRegion(clnt client.Client, region string) {
        q := fmt.Sprintf("SELECT count(%s) FROM %s where region = '%s'", "cpu_usage", "cpu", region)
        res, err := queryDB(clnt, q)
        if err != nil {
                log.Fatalln("Error: ", err)
        }
        count := res[0].Series[0].Values[0][1]
        fmt.Printf("Found a total of %v records for region '%s'\n", count, region)
}

Listing 6-5.Writing and Reading of Points to a Measurement “cpu” in InfluxDB

```

函数`influxDBClient`返回一个`Client`对象，该对象用于 InfluxDB 的读写操作。`createMetrics`功能用于批量写点。为了举例，100 个点被插入到一个名为`cpu`的`measurement`中。`tagset`中包含两个`tags`:T7 和 T8。`measurement cpu`有一个`field`名为`cpu_usage`。

为了执行读操作，函数`queryDB`被用作助手函数，它在执行给定的查询命令后返回一部分`client.Result`。在这个例子中，使用助手函数`queryDB`执行了三个查询操作。函数`readWithLimit`从`measurement cpu`读取数据，限制为 10。函数`meanCPUUsage`为`region "us-west"`从`measurement cpu`中读取`cpu_usage`的`mean`值。最后，函数`countRegion`从`measurement cpu`读取`region us-west`的点数。

执行读取操作时，您应该会看到类似如下的输出:

```go
[ 0] Sep 17 10:49:42: 11.901734
[ 1] Sep 17 10:49:42: 15.471216
[ 2] Sep 17 10:49:42: 32.904423
[ 3] Sep 17 10:49:42: 15.973031
[ 4] Sep 17 10:49:42: 88.648864
[ 5] Sep 17 10:49:42: 92.049809
[ 6] Sep 17 10:49:42: 83.304049
[ 7] Sep 17 10:49:42: 18.495674
[ 8] Sep 17 10:49:42: 23.389015
[ 9] Sep 17 10:49:42: 46.009337
Mean value of cpu_usage for region 'us-west':46.268998
Found a total of 27 records for region 'us-west'

```

您可以从`influx`命令行界面工具执行查询操作。让我们运行该工具并执行一个查询:

```go
$ influx
> select * from cpu limit 10

```

上述命令提供了类似于以下内容的数据:

```go
name: cpu
---------
time                     cpu_usage               host            region
1474109382000000000      11.901733613473244      192.168.1.21    us-west
1474109382000000000      15.47121626535387       192.168.99.62   us-east
1474109382000000000      32.9044231821345        192.168.98.18   us-north
1474109382000000000      15.97303140480521       192.168.97.1    us-central
1474109382000000000      88.64886440612389       192.168.96.13   us-north
1474109382000000000      92.04980918501607       192.168.95.74   us-central
1474109382000000000      83.30404929547693       192.168.91.22   us-west
1474109382000000000      18.495673741297637      192.168.90.58   us-west
1474109382000000000      23.38901519689525       192.168.9.91    us-west
1474109382000000000      46.00933676790605       192.168.9.30    us-central

```

## 6-4.使用 SQL 数据库

### 问题

您希望在自己的 Go 应用程序中使用 PostgreSQL、MySQL 等关系数据库。

### 解决办法

标准库包`database/sql`为使用 SQL 数据库提供了一个通用接口。要使用任何特定的 SQL 数据库，您必须使用特定于数据库的驱动程序和包`database/sql`。可以在 [`http://golang.org/s/sqldrivers`](http://golang.org/s/sqldrivers) 找到与包`database/sql`一起工作的第三方 SQL 驱动程序列表。

### 它是如何工作的

包`database/sql`提供了一个通用接口，用于处理各种 SQL 数据库。虽然`database/sql`为 SQL 数据库提供了一个通用接口，但是它不包含任何特定的数据库驱动程序。因此你必须使用一个第三方的包，它提供了包`database/sql`的实现。例如，如果您想使用 PostgreSQL 数据库，您必须为`database/sql`使用 PostgreSQL 的数据库驱动程序。

#### 使用 PostgreSQL

第三方包`pq` ( `github.com/lib/pq`)是`database/sql`的 PostgreSQL 驱动，用 Go 写的。要安装软件包`pq`，运行以下命令:

```go
go get github.com/lib/pq

```

要使用包`pq`，您只需要导入驱动程序，就可以使用包`database/sql`提供的完整 API。下面代码块中的`init`函数打开一个 PostgreSQL 数据库:

```go
import (
        "database/sql"        

        _ "github.com/lib/pq"
)

var db *sql.DB

func init() {
        var err error
        db, err = sql.Open("postgres", "postgres://user:pass@localhost/dbname")
        if err != nil {
                log.Fatal(err)
        }        
}

```

当您使用 SQL 数据库时，您通常使用包`database/sql`的 API，但是您可能不需要直接访问特定数据库驱动程序的包的功能。在这里，您使用包`pq`只是为了调用它的`init`函数，将您的驱动程序`"postgres"`注册到`database/sql`。因为包`pq`的导入只是为了调用它的`init`函数，所以使用一个空白标识符`(_)`作为包别名以避免编译错误。

包`database/sql`的函数`Open`打开一个由其数据库驱动程序名和驱动程序特定的数据源名指定的数据库，通常至少包含一个数据库名和连接信息。这里的数据库驱动名是`"postgres"`。函数`Open`返回`*sql.DB`，它代表包`sql`为您的数据库提供的连接池。

#### 使用 MySQL

第三方包`mysql` ( `github.com/go-sql-driver/mysql`)是`database/sql`的 MySQL 驱动。要安装软件包`mysql`，运行以下命令:

```go
go get github.com/go-sql-driver/mysql

```

要使用包`mysql`，您只需要导入驱动程序，就可以使用包`database/sql`提供的完整 API。下面代码块中的`init`函数打开一个 MySQL 数据库:

```go
import (
        "database/sql"        

        _ " github.com/go-sql-driver/mysql"
)

var db *sql.DB

func init() {
        var err error
        db, err = sql.Open("mysql", "user:password@/dbname")
        if err != nil {
                log.Fatal(err)
        }        
}

```

包`database/sql`的函数`Open`打开一个带有驱动名`“mysql”`和给定数据源名的数据库。

#### PostgreSQL 数据库示例

让我们编写一个示例程序来演示如何使用包`database/sql`和`pq`使用 PostgreSQL 数据库。以下 SQL 语句用于为示例程序创建表结构:

```go
create table products (
  id                    serial primary key,
  title           varchar(255) NOT NUL,
  description   varchar(255) NOT NUL,
  price             decimal(5,2) NOT NULL
);

```

清单 [6-6](#Par196) 展示了一个示例程序，该程序演示了在名为`productstore`的数据库上使用 PostgreSQL 数据库进行插入和读取操作。

```go
package main

import (
        "database/sql"
        "fmt"
        "log"

        _ "github.com/lib/pq"
)

// Product struct provides the data model for productstore
type Product struct {
        ID          int
        Title       string
        Description string
        Price       float32
}

var db *sql.DB

func init() {
        var err error
        db, err = sql.Open("postgres", "postgres://user:pass@localhost/productstore")
        if err != nil {
                log.Fatal(err)
        }
}
func main() {
        product := Product{
                Title:       "Amazon Echo",
                Description: "Amazon Echo - Black",
                Price:       179.99,
        }
        // Insert a product
        createProduct(product)
        // Read all product records
        getProducts()
}

// createProduct inserts product values into product table
func createProduct(prd Product) {
        result, err := db.Exec("INSERT INTO products(title, description, price) VALUES($1, $2, $3)", prd.Title, prd.Description, prd.Price)
        if err != nil {
                log.Fatal(err)
        }

        lastInsertID, err := result.LastInsertId()
        rowsAffected, err := result.RowsAffected()
        fmt.Printf("Product with id=%d created successfully (%d row affected)\n", lastInsertID, rowsAffected)
}

// getProducts reads all records from the product table
func getProducts() {
        rows, err := db.Query("SELECT * FROM products")
        if err != nil {
                if err == sql.ErrNoRows {
                        fmt.Println("No Records Found")
                        return
                }
                log.Fatal(err)
        }
        defer rows.Close()

        var products []*Product
        for rows.Next() {
                prd := &Product{}
                err := rows.Scan(&prd.Title, &prd.Description, &prd.Price)
                if err != nil {
                        log.Fatal(err)
                }
                products = append(products, prd)
        }
        if err = rows.Err(); err != nil {
                log.Fatal(err)
        }

        for _, pr := range products {
                fmt.Printf("%s, %s, $%.2f\n", pr.Title, pr.Description, pr.Price)
        }
}

Listing 6-6.Insert and Read Operation with a Database productstore in PostgreSQL

```

在函数`init`中创建一个`*sql.DB`对象，通过提供数据库驱动程序名称作为`“postgres”`和数据源名称来使用 PostgreSQL 数据库。

```go
var db *sql.DB

func init() {
        var err error
        db, err = sql.Open("postgres", "postgres://user:pass@localhost/productstore")
        if err != nil {
                log.Fatal(err)
        }
}

```

`*sql.DB`对象用于执行插入和读取操作。为了向数据库表中插入记录，`sql.DB`对象的函数`Exec`用于执行查询，而不返回任何行。插入记录的值使用占位符参数传递，占位符参数使用`$N`符号。占位符参数的语法在不同的数据库中是不同的。例如，MySQL 和 SQL Server 使用字符`?`作为占位符。函数`Exec`返回一个`sql.Result`值，有两个方法:`LastInsertId`和`RowsAffected. LastInsertId`返回数据库生成的整数值，可以用来获取的值，并在插入新行时自动递增列。`RowsAffected`返回受更新、插入或删除操作影响的行数。

```go
func createProduct(prd Product) {
        result, err := db.Exec("INSERT INTO products(title, description, price) VALUES($1, $2, $3)", prd.Title, prd.Description, prd.Price)
        if err != nil {
                log.Fatal(err)
        }

        lastInsertID, err := result.LastInsertId()
        rowsAffected, err := result.RowsAffected()
        fmt.Printf("Product with id=%d created successfully (%d row affected)\n", lastInsertID, rowsAffected)
}

```

为了执行 SQL 语句`SELECT`来查询数据，使用了`sql.DB`对象的函数`Query`，它返回一个 struct 类型的值`Rows`。

```go
rows, err := db.Query("SELECT * FROM products")

```

通过调用`Rows`对象的方法`Next`，可以使用`Scan`方法读取下一行的值。

```go
var products []*Product
        for rows.Next() {
                prd := &Product{}
                err := rows.Scan(&prd.Title, &prd.Description, &prd.Price)
                if err != nil {
                        log.Fatal(err)
                }
                products = append(products, prd)
        }
        if err = rows.Err(); err != nil {
                log.Fatal(err)
}

```

当您执行一个获取单行的查询时，您可以使用函数`QueryRow`来执行一个查询并返回一行。下面是一个使用`QueryRow`获取一行的示例代码块:

```go
   id := 1
    var product string
  err := db.QueryRow("SELECT title FROM products WHERE id=$1", id).Scan(&product)    
switch {
    case err == sql.ErrNoRows:
            log.Printf("No product with that ID.")
    case err != nil:
            log.Fatal(err)
    default:
            fmt.Printf("Product is %s\n", product)
    }

```

当您运行清单 [6-6](#Par196) 中的程序时，您应该会看到类似如下的输出:

```go
Product with id=1 created successfully (1 row affected)
Amazon Echo, Amazon Echo - Black, $179.99

```

使用标准库包`database/sql`和第三方的特定数据库驱动包，如 PostgreSQL 数据库的`github.com/lib/pq`，您可以使用各种 SQL 数据库。使用包`database/sql`的好处是你可以使用同一个接口来处理不同的数据库。